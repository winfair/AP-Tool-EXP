<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover,user-scalable=no"/>
  <title>Geo‑Pointer with Pin Drop</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#0b0f12; color:#e8f1f0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #map { position:absolute; top:0; left:0; width:35%; height:100%; z-index:5; }
    #canvas { position:absolute; top:0; left:35%; width:65%; height:100%; z-index:1; }
    .panel { position:absolute; top:12px; right:12px; z-index:10; background:rgba(10,14,18,0.8); padding:0.8rem; border-radius:10px; }
    .btn { padding:0.5rem 1rem; margin:0.3rem; background:#222; border:none; color:#e8f1f0; cursor:pointer; border-radius:6px; }
    .tiny { font-size:0.85rem; color:#9fc0b8; }
    #readout { position:absolute; bottom:12px; left:35%; width:65%; padding:0.4rem 0.65rem; background:rgba(0,0,0,0.32); color:#e8f1f0; font-variant-numeric:tabular-nums; border-radius:10px; }  
  </style>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
</head>
<body>
  <div id="map"></div>
  <canvas id="canvas"></canvas>
  <div class="panel">
    <button id="useGps" class="btn">Use My Location</button>
    <button id="calYaw" class="btn">Calibrate Yaw</button>
    <div class="tiny">Click map to drop a pin (target)</div>
  </div>
  <div id="readout">az: —° el: —° | me: —, — | target: —, —</div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js" crossorigin="anonymous"></script>
  <script>
    (function(){
      // Map setup
      const map = L.map('map').setView([0,0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
      }).addTo(map);

      let pinMarker = null;
      let tgt = {lat:null, lon:null, alt:0, valid:false};
      map.on('click', e => {
        if (pinMarker) map.removeLayer(pinMarker);
        pinMarker = L.marker(e.latlng).addTo(map);
        tgt = { lat: e.latlng.lat, lon: e.latlng.lng, alt: 0, valid:true };
      });

      // Three.js setup
      const canvas   = document.getElementById('canvas');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
      renderer.setPixelRatio(Math.min(devicePixelRatio,2));
      const scene    = new THREE.Scene();
      const camera   = new THREE.PerspectiveCamera(55, 1, 0.1, 1000);
      camera.position.set(0,0,0);
      const rig     = new THREE.Group();
      rig.add(camera);
      scene.add(rig);

      // Arrow
      const arrowLen = 15;
      const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), arrowLen, 0xff4d4d);
      scene.add(arrow);

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff,0.8));
      const dl = new THREE.DirectionalLight(0xffffff,0.6);
      dl.position.set(5,5,5);
      scene.add(dl);

      // UI
      const btnGPS = document.getElementById('useGps');
      const btnCal = document.getElementById('calYaw');
      const readoutEl = document.getElementById('readout');

      // State
      let obs = {lat:0, lon:0, alt:0, valid:false};
      let yaw=0, pitch=0, roll=0;
      let yawCal = 0, yawSm=0, pitchSm=0, rollSm=0;

      const a = 6378137, f = 1/298.257223563, e2 = f*(2-f);
      const d2r = d => d * Math.PI/180, r2d = r => r * 180/Math.PI;

      function geodeticToECEF(lat, lon, h){
        const φ = d2r(lat), λ = d2r(lon);
        const s = Math.sin(φ), c = Math.cos(φ);
        const N = a / Math.sqrt(1 - e2*s*s);
        const x = (N + h)*c*Math.cos(λ);
        const y = (N + h)*c*Math.sin(λ);
        const z = (N*(1 - e2) + h)*s;
        return {x,y,z};
      }

      function ecefToENU(dx,dy,dz, lat0, lon0){
        const φ = d2r(lat0), λ = d2r(lon0);
        const sφ = Math.sin(φ), cφ = Math.cos(φ);
        const sλ = Math.sin(λ), cλ = Math.cos(λ);
        const e = -sλ*dx + cλ*dy;
        const n = -sφ*cλ*dx - sφ*sλ*dy + cφ*dz;
        const u =  cφ*cλ*dx + cφ*sλ*dy + sφ*dz;
        return {e,n,u};
      }

      function computeDir(){
        if (!obs.valid || !tgt.valid) return null;
        const A = geodeticToECEF(obs.lat, obs.lon, obs.alt);
        const B = geodeticToECEF(tgt.lat, tgt.lon, tgt.alt);
        const dx = B.x - A.x, dy = B.y - A.y, dz = B.z - A.z;
        const enu = ecefToENU(dx,dy,dz, obs.lat, obs.lon);
        const dirVec = new THREE.Vector3(enu.e, enu.u, enu.n).normalize();
        const az = Math.atan2(enu.e, enu.n);
        const el = Math.atan2(enu.u, Math.hypot(enu.e, enu.n));
        return { dir:dirVec, az, el };
      }

      function wrapRad(a){
        a %= (2*Math.PI);
        if (a < -Math.PI) a += 2*Math.PI;
        if (a >  Math.PI) a -= 2*Math.PI;
        return a;
      }

      function update(){
        const res = computeDir();
        const k = 0.18; // fixed smoothing for simplicity
        yawSm   += wrapRad((yaw + yawCal)*Math.PI/180 - yawSm)*k;
        pitchSm += (pitch*Math.PI/180 - pitchSm)*k;
        rollSm  += (roll*Math.PI/180 - rollSm)*k;
        rig.rotation.set(pitchSm, yawSm, rollSm);

        if (res){
          arrow.setDirection(res.dir);
          readoutEl.textContent = `az:${r2d(res.az).toFixed(1)}° el:${r2d(res.el).toFixed(1)}° | me:${obs.lat.toFixed(6)},${obs.lon.toFixed(6)} | tgt:${tgt.lat.toFixed(6)},${tgt.lon.toFixed(6)}`;
        } else {
          readoutEl.textContent = `az:—° el:—° | me:${obs.lat.toFixed(6)},${obs.lon.toFixed(6)} | tgt:—,—`;
        }
      }

      btnGPS.addEventListener('click', ()=>{
        if (!navigator.geolocation) { statusEl.textContent="GPS unavailable"; return; }
        navigator.geolocation.watchPosition(p=> {
          const c = p.coords;
          const kLoc = 0.25;
          if (!obs.valid) obs = {lat:c.latitude, lon:c.longitude, alt:c.altitude||0, valid:true};
          else {
            obs.lat = obs.lat*(1-kLoc) + c.latitude*kLoc;
            obs.lon = obs.lon*(1-kLoc) + c.longitude*kLoc;
            obs.alt = obs.alt*(1-kLoc) + (c.altitude||0)*kLoc;
          }
        }, e=> {
          statusEl.textContent = `GPS error: ${e.message}`;
        }, { enableHighAccuracy:true, maximumAge:3000, timeout:15000 });
      });

      btnCal.addEventListener('click', ()=> {
        yawCal = - yaw;
      });

      window.addEventListener('deviceorientation', e => {
        if (typeof e.webkitCompassHeading === 'number') yaw = e.webkitCompassHeading;
        else if (typeof e.alpha === 'number') yaw = (360 - e.alpha)%360;
        pitch = (typeof e.beta  === 'number'? e.beta-90 : 0);
        roll  = (typeof e.gamma === 'number'? e.gamma : 0);
        update();
      }, true);

      function resize(){
        const w = canvas.clientWidth || window.innerWidth;
        const h = canvas.clientHeight|| window.innerHeight;
        renderer.setSize(w,h,false);
        camera.aspect = w/h;
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', resize, {passive:true});
      resize();

      function animate(){
        requestAnimationFrame(animate);
        update();
        renderer.render(scene, camera);
      }
      animate();

    })();
  </script>
</body>
</html>
