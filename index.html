<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>North Arrow — Minimal</title>
<style>
  :root{--bg:#0b0f12;--ink:#e8f1f0;--line:rgba(255,255,255,.12)}
  html,body{height:100%;margin:0;background:radial-gradient(120% 140% at 50% 20%,#131a20 0%,#0b0f12 60%,#06080a 100%);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  #canvas{position:fixed;inset:0;display:block;width:100%;height:100%}
  #perm{position:fixed;right:12px;bottom:12px;z-index:10;appearance:none;border:1px solid var(--line);background:rgba(255,255,255,.06);color:var(--ink);padding:.55rem .8rem;border-radius:12px;font-weight:600}
  #readout{position:fixed;left:12px;bottom:12px;opacity:.7;font-variant-numeric:tabular-nums}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<button id="perm" type="button" title="Enable motion/compass (iOS needs a tap)">Enable Sensors</button>
<div id="readout">—°</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js" crossorigin="anonymous"></script>
<script>
// A *minimal* 3D arrow that points to geographic north on the screen.
// The arrow is rendered in 3D but rotated by the device heading so its tip
// always points toward the North Pole relative to the phone.
(function(){
  const canvas = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 1000);
  camera.position.set(0, 0, 5);

  // Simple lighting
  scene.add(new THREE.AmbientLight(0xffffff, 0.8));
  const dl = new THREE.DirectionalLight(0xffffff, 0.6); dl.position.set(3,4,5); scene.add(dl);

  // Arrow model: points "up" (toward +Y) by default; we'll rotate around Z to aim at north
  const arrow = new THREE.Group();
  const shaftMat = new THREE.MeshStandardMaterial({color:0xe8f1f0, metalness:.25, roughness:.35});
  const tipMat   = new THREE.MeshStandardMaterial({color:0xff4d4d, metalness:.35, roughness:.25});
  const baseMat  = new THREE.MeshStandardMaterial({color:0x22d7b7, metalness:.35, roughness:.35});
  const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,2.6,20), shaftMat); shaft.position.y = 1.1; arrow.add(shaft);
  const tip   = new THREE.Mesh(new THREE.ConeGeometry(0.18,0.6,28), tipMat); tip.position.y = 2.4; arrow.add(tip);
  const base  = new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,0.16,28), baseMat); base.position.y = 0.02; arrow.add(base);
  // Subtle ground disc for depth
  const ground = new THREE.Mesh(new THREE.CircleGeometry(2.3, 96), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:.04}));
  ground.rotation.x = -Math.PI/2; ground.position.y = -0.02; scene.add(ground);

  scene.add(arrow);

  // Resize handler
  function resize(){
    const w = canvas.clientWidth || window.innerWidth;
    const h = canvas.clientHeight || window.innerHeight;
    renderer.setSize(w, h, false); camera.aspect = w/h; camera.updateProjectionMatrix();
  }
  addEventListener('resize', resize, {passive:true}); resize();

  // ===== Sensor plumbing (heading in degrees, 0 = North) =====
  let heading = 0; // will be updated from sensors
  const readout = document.getElementById('readout');
  const permBtn = document.getElementById('perm');
  let sensorsOn = false;

  function setHeading(deg){
    // Normalize to [0,360)
    heading = ((deg % 360) + 360) % 360;
    readout.textContent = heading.toFixed(1) + '°';
  }

  // Primary: AbsoluteOrientationSensor → yaw → heading
  function startAOS(){
    try{
      const AOS = window.AbsoluteOrientationSensor || window.RelativeOrientationSensor;
      if (!AOS) return false;
      const s = new AOS({frequency:60, referenceFrame:'device'});
      s.addEventListener('reading', ()=>{
        const q = s.quaternion; // [x,y,z,w]
        // Yaw from quaternion (assuming ENU):
        const x=q[0], y=q[1], z=q[2], w=q[3];
        const siny_cosp = 2*(w*z + x*y);
        const cosy_cosp = 1 - 2*(y*y + z*z);
        const yaw = Math.atan2(siny_cosp, cosy_cosp); // radians
        // Convert yaw to compass heading where 0° = North (screen up), increasing clockwise
        const hdg = ((THREE.MathUtils.radToDeg(yaw) - 90) % 360 + 360) % 360;
        setHeading(hdg);
      });
      s.addEventListener('error', e=>console.warn('AOS error', e.error||e));
      s.start();
      sensorsOn = true;
      return true;
    }catch(e){ console.warn('AOS unavailable', e); return false; }
  }

  // Fallback: DeviceOrientation
  function startDO(){
    const useAbs = 'ondeviceorientationabsolute' in window;
    const evt = useAbs ? 'deviceorientationabsolute' : 'deviceorientation';
    function handler(e){
      if (typeof e.webkitCompassHeading === 'number'){
        setHeading(e.webkitCompassHeading);
      } else if (typeof e.alpha === 'number'){
        setHeading(360 - e.alpha); // heuristic (alpha increases CCW from device facing)
      }
    }
    window.addEventListener(evt, handler, true);
    sensorsOn = true;
    return true;
  }

  async function enable(){
    try{
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
        await DeviceMotionEvent.requestPermission();
      }
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
        await DeviceOrientationEvent.requestPermission();
      }
    }catch(_){/* ignore */}
    if (!startAOS()) startDO();
  }

  // Auto-start on non‑iOS; iOS needs a gesture
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints>1);
  if (!isIOS) { if (!startAOS()) startDO(); }
  permBtn.addEventListener('click', enable, {passive:true});

  // ===== Render loop =====
  function animate(){
    requestAnimationFrame(animate);
    // Rotate arrow so that it *points toward north* at the top of the screen.
    // Arrow model points +Y; heading 0 => up → rotation.z = 0; clockwise heading rotates arrow clockwise
    arrow.rotation.set(0,0,THREE.MathUtils.degToRad(-heading));
    renderer.render(scene, camera);
  }
  animate();
})();
</script>
</body>
</html>
