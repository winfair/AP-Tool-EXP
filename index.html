<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"/>
<meta name="theme-color" content="#0b0f12"/>
<title>AP Alignment ‚Äî Minimap Edition</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous"/>
<script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>

<style>
:root{
  --bg:#0b0f12; --ink:#eafaf5; --muted:#9ed6c2; --brand:#17f0c8; --brand-2:#2ac18a;
  --line:rgba(255,255,255,.1); --line2:rgba(255,255,255,.18);
  --glass:rgba(12,18,20,.7); --glass2:rgba(12,18,20,.88);
  --shadow:0 16px 40px rgba(0,0,0,.55);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:radial-gradient(1200px 1000px at 50% 110%, #0b0f12 40%, #06080a 100%);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,ui-sans-serif}
a{color:var(--muted)}
/* ===== Layout ============================================================ */
.app{
  position:fixed; inset:0; display:grid;
  grid-template-rows: 64px 1fr 120px;
  grid-template-columns: 1fr;
}
.topbar{
  display:flex; align-items:center; gap:12px; padding:12px 14px;
  border-bottom:1px solid var(--line2);
  background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.00));
  backdrop-filter: blur(8px);
  z-index:20;
}
.brand{ font-weight:800; letter-spacing:.3px; font-size:15px; opacity:.9 }
.btn{
  appearance:none; border:1px solid var(--line);
  background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
  color:var(--ink); border-radius:12px; padding:10px 12px; font-weight:700; cursor:pointer;
}
.btn.ghost{ background:transparent }
.btn.glow{ border-color:var(--brand); box-shadow:0 0 0 1px rgba(23,240,200,.2), 0 0 32px rgba(23,240,200,.18) inset }
.btn.small{ padding:8px 10px; font-size:13px }
.spacer{flex:1}

/* ===== Minimap ========================================================== */
.stage{ position:relative; display:grid; place-items:center; overflow:hidden; }
.minimap{
  position:relative; width:min(88vmin, 700px); aspect-ratio:1/1;
  border-radius:50%;
  box-shadow: 0 12px 32px rgba(0,0,0,.55), 0 0 0 1px var(--line2) inset,
              0 0 60px rgba(23,240,200,.08) inset;
  background: radial-gradient(60% 60% at 50% 50%, rgba(23,240,200,.06), rgba(23,240,200,.01) 60%, rgba(0,0,0,.0) 62%),
              radial-gradient(90% 90% at 50% 50%, rgba(0,0,0,.0) 60%, rgba(23,240,200,.07) 102%);
}
.map-wrap{
  position:absolute; inset:3%; border-radius:50%; overflow:hidden;
  filter: drop-shadow(0 20px 30px rgba(0,0,0,.35));
  /* give Leaflet a predictable size path */
  width:94%; height:94%;
}
#map{
  position:absolute; inset:-6%;
  /* explicit dimensions ensure Leaflet sees a real size immediately */
  width:112%; height:112%;
  will-change:transform;
}
.ring, .ring2{
  position:absolute; inset:0; border-radius:50%; pointer-events:none;
  border:1px dashed rgba(255,255,255,.14);
}
.ring2{ inset:6%; border-style:solid; border-width:2px; border-color:rgba(23,240,200,.12) }
.cardinals{
  position:absolute; inset:0; display:grid; place-items:center; pointer-events:none;
  font-weight:800; letter-spacing:1.5px; font-size:10px; color:#b6fff0aa; text-shadow:0 1px 0 #000;
}
.cardinals span{ position:absolute }
.cardinals .N{ top:2% } .S{ bottom:2% } .E{ right:3% } .W{ left:3% }
/* Sweep beam */
.sweep{ position:absolute; inset:3%; border-radius:50%; overflow:hidden; pointer-events:none; mix-blend-mode:screen }
.sweep::before{
  content:""; position:absolute; inset:-20%;
  background: conic-gradient(from 0deg,
      rgba(23,240,200,0) 0deg,
      rgba(23,240,200,.0) 5deg,
      rgba(23,240,200,.15) 12deg,
      rgba(23,240,200,.06) 18deg,
      rgba(23,240,200,0) 24deg);
  animation:spin 4s linear infinite;
  filter:blur(1.6px);
}
@keyframes spin{ to{ transform:rotate(360deg) } }

/* Target pings */
.ping{
  position:absolute; width:10px; height:10px; border-radius:50%;
  background:radial-gradient(circle, #bffff3, #17f0c8 60%, #17f0c800 62%);
  box-shadow:0 0 24px rgba(23,240,200,.65), 0 0 0 1px rgba(23,240,200,.7) inset;
  transform:translate(-50%,-50%);
  pointer-events:none;
}
.ping.flash{ animation:ping 0.7s ease-out 1 }
@keyframes ping{
  0%{ box-shadow:0 0 0 2px rgba(23,240,200,.9), 0 0 20px rgba(23,240,200,.9) }
  100%{ box-shadow:0 0 0 10px rgba(23,240,200,0), 0 0 40px rgba(23,240,200,0) }
}

/* ===== HUD bottom ======================================================= */
.hud{ display:grid; grid-template-columns: 1fr auto 1fr; align-items:center; gap:12px; padding:10px 14px 20px }
.stat{ display:flex; gap:8px; align-items:baseline; flex-wrap:wrap }
.k{color:var(--muted); font-weight:700; font-size:12px}
.v{font-weight:900; font-variant-numeric:tabular-nums}
.center-controls{ display:flex; gap:10px }
.badge{ padding:8px 10px; border-radius:10px; border:1px solid var(--line); background:var(--glass2) }

/* ===== Radial Menu ====================================================== */
.radial{ position:fixed; inset:0; display:none; place-items:center; z-index:40; background:rgba(0,0,0,.35); backdrop-filter:blur(3px) }
.radial.open{ display:grid }
.radial .ring{
  position:relative; width:min(70vmin,560px); aspect-ratio:1/1; border-radius:50%;
  border:1px solid var(--line2); background:radial-gradient(50% 50% at 50% 50%, rgba(23,240,200,.06), rgba(23,240,200,0) 60%);
  box-shadow:0 0 0 1px rgba(23,240,200,.15) inset, 0 50px 80px rgba(0,0,0,.45);
}
.radial .action{ position:absolute; transform:translate(-50%,-50%); width:44%; max-width:230px; display:grid; place-items:center; text-align:center; gap:8px }
.radial .action .btn{ width:100% }
.radial .label{font-size:12px; color:var(--muted)}
.radial .close{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%) }

/* ===== Leaflet tweaks =================================================== */
.leaflet-container{ background:transparent }
.leaflet-control-attribution, .leaflet-control-zoom{ filter:drop-shadow(0 6px 12px rgba(0,0,0,.35)) }
.leaflet-tooltip.mini{ background:rgba(0,0,0,.5); border:1px solid var(--line2); color:#dffcf5; border-radius:8px; padding:2px 6px }

/* Error toast */
.toast{
  position:fixed; left:12px; right:12px; top:12px; z-index:50;
  background:#2a1d1d; color:#ffdede; border:1px solid #ff6b6b; border-radius:10px;
  padding:10px 36px 10px 12px; font-weight:700; display:none;
}
.toast .x{ position:absolute; right:8px; top:6px; background:transparent; border:none; color:#ffdede; font-weight:900; cursor:pointer }
</style>
</head>
<body>
<div class="app">
  <!-- Top -->
  <div class="topbar">
    <div class="brand">AP Alignment ‚Äî Minimap</div>
    <div class="spacer"></div>
    <button id="btnMenu" class="btn small ghost" title="Menu">‚öôÔ∏è</button>
  </div>

  <!-- Stage -->
  <div class="stage">
    <div class="minimap" aria-label="Minimap">
      <div class="ring"></div>
      <div class="ring2"></div>
      <div class="map-wrap">
        <div id="map" aria-label="Map"></div>
      </div>
      <div class="cardinals">
        <span class="N">N</span><span class="S">S</span><span class="E">E</span><span class="W">W</span>
      </div>
      <div class="sweep" id="sweep"></div>
    </div>
  </div>

  <!-- HUD -->
  <div class="hud">
    <div class="stat">
      <span class="k">LAT</span><span id="hudLat" class="v">‚Äî</span>
      <span class="k">LNG</span><span id="hudLng" class="v">‚Äî</span>
      <span class="k">ACC</span><span id="hudAcc" class="v">‚Äî m</span>
    </div>
    <div class="center-controls">
      <button id="btnGPS" class="btn glow" title="Enable GPS (L)">üì° GPS</button>
      <button id="btnRotate" class="btn" title="Toggle Rotate/Compass (R)">üß≠ Rotate</button>
      <button id="btnReset" class="btn" title="Recenter / Clear Nav (C)">‚Ü∫ Reset</button>
    </div>
    <div class="stat" style="justify-self:end">
      <span class="k">HEAD</span><span id="hudHead" class="v">‚Äî¬∞</span>
      <span class="k">MAP</span><span id="hudMap" class="v">‚Äî¬∞</span>
      <span class="k">ALIGN</span><span id="hudAlign" class="v">‚Äî</span>
    </div>
  </div>
</div>

<!-- Radial menu -->
<div id="radial" class="radial" aria-hidden="true">
  <div class="ring">
    <button class="btn close" id="radialClose">‚úï</button>

    <div class="action" style="top:14%; left:50%">
      <div class="label">Declination</div>
      <input id="declSlider" type="range" min="-30" max="30" step="0.1" style="width:100%"/>
      <div class="badge">True = Magnetic + <b id="declVal">0.0¬∞</b></div>
      <button id="declSave" class="btn glow">Save</button>
    </div>

    <div class="action" style="top:50%; left:85%">
      <div class="label">Waypoints</div>
      <div class="badge" style="width:100%; text-align:left">
        <div style="display:grid; gap:8px">
          <input id="wpName" placeholder="Name" class="btn" style="text-align:left"/>
          <input id="wpCoords" placeholder="34.851939,-119.168399" class="btn" style="text-align:left"/>
          <button id="wpAdd" class="btn glow">Add / Update</button>
          <div id="wpList" style="max-height:180px; overflow:auto; border:1px solid var(--line); border-radius:10px; padding:6px"></div>
        </div>
      </div>
    </div>

    <div class="action" style="top:86%; left:50%">
      <div class="label">Platform</div>
      <label class="badge" style="display:flex; gap:10px; align-items:center">
        <input type="checkbox" id="invertAndroid"/> Invert Android heading
      </label>
    </div>

    <div class="action" style="top:50%; left:15%">
      <div class="label">Shortcuts</div>
      <button id="rmGPS" class="btn">üì° Start GPS</button>
      <button id="rmRotate" class="btn">üß≠ Toggle Rotate</button>
      <button id="rmReset" class="btn">‚Ü∫ Reset</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div id="toast" class="toast"><button class="x" id="toastX">√ó</button><span id="toastMsg"></span></div>

<script>
'use strict';
(function(){
  const ready = (fn) => {
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(fn, 0);
    } else {
      document.addEventListener('DOMContentLoaded', fn, { once: true });
    }
  };

  /* ===================== utilities ===================== */
  const $ = id => document.getElementById(id);
  const R = d => d * Math.PI/180;
  const Dg = r => r * 180/Math.PI;
  const N = d => ((d % 360) + 360) % 360;
  const Œî = (a, b) => { let d = N(b) - N(a); if (d > 180) d -= 360; else if (d < -180) d += 360; return d; };
  const blend = (p, n, a) => p == null ? n : N(p + a * Œî(p, n));
  const fix = v => Number(v).toFixed(6);
  const fmtDist = m => (m < 1000) ? `${Math.round(m)} m` : `${(m/1000).toFixed(2)} km`;
  const haversine = (a, b) => {
    const Rm = 6371000, œÜ1 = R(a.lat), œÜ2 = R(b.lat), dœÜ = R(b.lat-a.lat), dŒª = R(b.lng-a.lng);
    const s = Math.sin(dœÜ/2)**2 + Math.cos(œÜ1)*Math.cos(œÜ2)*Math.sin(dŒª/2)**2;
    return 2*Rm*Math.asin(Math.min(1, Math.sqrt(s)));
  };
  const bearing = (a, b) => {
    const œÜ1=R(a.lat), œÜ2=R(b.lat), Œª1=R(a.lng), Œª2=R(b.lng);
    const y=Math.sin(Œª2-Œª1)*Math.cos(œÜ2);
    const x=Math.cos(œÜ1)*Math.sin(œÜ2)-Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(Œª2-Œª1);
    return N(Dg(Math.atan2(y,x)));
  };
  const DotIcon = s => L.divIcon({ className: 'ping', iconSize:[s,s], iconAnchor:[s/2,s/2] });
  const makeDot = (lat,lng,size=10) => L.marker([lat,lng], { icon: DotIcon(size), riseOnHover:true });

  /* Android screen angle + sniff */
  const getScreenAngle = () => {
    if (screen && screen.orientation && typeof screen.orientation.angle === 'number') return screen.orientation.angle;
    const o = window.orientation; return (typeof o === 'number') ? (o % 360 + 360) % 360 : 0;
  };
  const isAndroid = () => /Android/i.test(navigator.userAgent || '') || /\bAdr\b/i.test(navigator.userAgent || '');

  /* toast */
  function toast(m){ const t=$('toast'), s=$('toastMsg'); if (!t||!s) { alert(m); return; }
    s.textContent=m; t.style.display='block'; }
  $('toastX')?.addEventListener('click', ()=>{ $('toast').style.display='none'; });

  /* ===================== state ===================== */
  const Store = {
    stateKey:'minimap.state.v1',
    wpKey:'minimap.waypoints.v1',
    loadState(){ try { return JSON.parse(localStorage.getItem(this.stateKey)||'{}'); } catch { return {}; } },
    saveState(s){ try { localStorage.setItem(this.stateKey, JSON.stringify(s)); } catch{} },
    loadWPs(){ try { return JSON.parse(localStorage.getItem(this.wpKey)||'[]'); } catch { return []; } },
    saveWPs(a){ try { localStorage.setItem(this.wpKey, JSON.stringify(a)); } catch{} }
  };

  const App = {
    S:{ follow:true, heading:null, bearing:0, rotate:false, decl:0, compass:false, omega:0, mag:null, dest:null },
    DEF:{ lat:34.9, lng:-119.17, z:16 },
    map:null, last:null, navLine:null, originDot:null, ray:null, accCircle:null,
    _lastOverlay:null, _compassBound:false, watchId:null,
    _tHUD:0, _tNav:0, _tAlign:0, _lastAlignLL:null, _lastAlignHead:null,
    _aligned:null,_pending:null,_flashName:null,_flashUntil:0,_flashCooldown:new Map(),_flashTarget:null,
    ALIGN:{ ENTER:0.35, EXIT:0.60, DWELL_BASE:60 }, RAY:{ ACTIVE:0.15 }, SCAN:{ FLASH:550, COOLDOWN:650 },
    WARMUP_MS:2000, _compassStartTs:null, DEAD_ZONE:0.5, MAX_STEP:5, _lastOrientEvent:null,

    init(){
      const s = Store.loadState();
      if (typeof s.follow==='boolean') this.S.follow=s.follow;
      if (typeof s.rotate==='boolean') this.S.rotate=s.rotate;
      if (typeof s.bearing==='number') this.S.bearing=N(s.bearing);
      if (typeof s.decl==='number') this.S.decl=+s.decl || 0;

      this.map = L.map('map',{ zoomControl:false, attributionControl:true, inertia:true });

      // Primary: Esri Topo; Fallback: OpenTopoMap
      const esri = L.tileLayer(
        'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',
        { maxZoom:19, attribution:'Tiles ¬© Esri ‚Äî Sources: Esri, Garmin, USGS, NPS, others' }
      );
      const otm = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
        { maxZoom:17, attribution:'Map data ¬© OpenStreetMap, SRTM ‚Äî Style ¬© OpenTopoMap (CC-BY-SA)' }
      );
      esri.addTo(this.map).on('tileerror', ()=>{ if (!this._fallbackSet){ this._fallbackSet=true; otm.addTo(this.map); } });

      this.map.setView([this.DEF.lat, this.DEF.lng], this.DEF.z);
      this.accCircle = L.circle([this.DEF.lat,this.DEF.lng],{radius:0,color:'#4df8ff',weight:1,opacity:.6,fillOpacity:.08}).addTo(this.map);

      this.bind();
      this.applyBearing(this.S.bearing);
      UI.sync(this.S); UI.declInit(this.S.decl);

      // Important: after layout settles, tell Leaflet to measure again
      setTimeout(()=>this.map.invalidateSize(), 50);

      this.loop();
      addEventListener('beforeunload',()=>{ this.persist(); this.stopGPS(); },{once:true});
    },

    bind(){
      $('btnGPS')?.addEventListener('click', ()=>this.startGPS());
      $('btnRotate')?.addEventListener('click', ()=>this.toggleRotate());
      $('btnReset')?.addEventListener('click', ()=>this.resetView());

      // keyboard
      addEventListener('keydown',e=>{
        const tag=(e.target&&e.target.tagName)||''; if (tag==='INPUT'||tag==='TEXTAREA'||e.metaKey||e.ctrlKey||e.altKey) return;
        const k=(e.key||'').toLowerCase();
        if (k==='l') this.startGPS();
        else if (k==='r') this.toggleRotate();
        else if (k==='c') this.resetView();
      });

      // radial menu
      const openRadial = (open)=>{ $('radial').classList.toggle('open', open); $('radial').setAttribute('aria-hidden',(!open).toString()); };
      $('btnMenu')?.addEventListener('click', ()=>openRadial(true));
      $('radialClose')?.addEventListener('click', ()=>openRadial(false));
      $('radial')?.addEventListener('click', e=>{ if(e.target.id==='radial') openRadial(false); });

      $('rmGPS')?.addEventListener('click', ()=>this.startGPS());
      $('rmRotate')?.addEventListener('click', ()=>this.toggleRotate());
      $('rmReset')?.addEventListener('click', ()=>this.resetView());

      // waypoints
      $('wpAdd')?.addEventListener('click', ()=>{
        const p = parseCoords($('wpCoords').value);
        if(!p){ toast('Could not parse coordinates.'); return; }
        Waypoints.upsert(($('wpName').value||'').trim(), p.lat, p.lng);
        $('wpName').value=''; $('wpCoords').value='';
      });
      $('wpList')?.addEventListener('click', e=>{
        const t=e.target, idx=t.getAttribute('data-idx'); if (idx==null) return; const i=+idx;
        if(t.hasAttribute('data-go')){
          const w=Waypoints.load()[i]; if(w){ this.S.follow=false; this.S.rotate=false; UI.sync(this.S); this.map.setView([w.lat,w.lng],16); Waypoints.ensureMarker(w.name)?.openPopup(); }
        }else if(t.hasAttribute('data-guide')){
          const w=Waypoints.load()[i]; if(w){ this.S.dest={lat:w.lat,lng:w.lng,name:w.name}; this.refreshNav(); UI.updateHUD(); }
        }else if(t.hasAttribute('data-del')){
          Waypoints.del(i);
        }
      });

      // declination
      $('declSlider')?.addEventListener('input',()=>{
        const v=parseFloat($('declSlider').value); if(Number.isFinite(v)){ this.S.decl=v; $('declVal').textContent=`${v.toFixed(1)}¬∞`; }
      },{passive:true});
      $('declSave')?.addEventListener('click', ()=>{
        const v=parseFloat($('declSlider').value); if(Number.isFinite(v)){ this.S.decl=v; if(this.S.mag!=null){ this._setHeadingFromOrient(); } this.persist(); UI.updateHUD(); }
        $('declSave').textContent='Saved ‚úì'; setTimeout(()=>{ $('declSave').textContent='Save'; }, 900);
      });

      // map gestures
      this.map.on('move moveend zoom zoomend zoomanim', ()=>{ this.applyBearing(this.S.bearing); this.refreshRay(); });
      addEventListener('resize',()=>{ this.map.invalidateSize(); this.applyBearing(this.S.bearing); this.refreshRay(); },{passive:true});

      // right-click / long-press
      this.map.on('contextmenu', e=>{
        const ll=e.latlng; Pins.drop(ll.lat,ll.lng); UI.flashPing(ll);
      });
    },

    persist(){ Store.saveState({ follow:this.S.follow, rotate:this.S.rotate, bearing:this.S.bearing, decl:this.S.decl }); },

    toggleRotate(){ (async()=>{
      if(!this.S.rotate){ if(!await this.enableCompass()) return; this.S.rotate=true; this.S.follow=true; }
      else this.S.rotate=false;
      UI.sync(this.S); this.applyBearing(this.S.bearing); this.persist();
    })(); },

    applyBearing(d){
      const pane=this.map.getPane && this.map.getPane('mapPane'); if(!pane) return;
      const base=(pane.style.transform||'').replace(/rotate\([^)]*\)/g,'');
      pane.style.transformOrigin='50% 50%';
      pane.style.transform=base+` rotate(${-d}deg)`;
      this.uprightOverlays(d);
    },
    uprightOverlays(deg){
      if(this._lastOverlay!=null && Math.abs(Œî(this._lastOverlay,deg))<0.12) return;
      this._lastOverlay=deg;
      const rot=` rotate(${deg}deg)`;
      const fixEl=el=>{ if(!el||!el.style) return; const base=(el.style.transform||'').replace(/rotate\([^)]*\)/g,'').trim(); el.style.transformOrigin='left center'; el.style.transform=base+rot; };
      this.map.getPanes().popupPane?.querySelectorAll('.leaflet-popup').forEach(fixEl);
      this.map.getPanes().tooltipPane?.querySelectorAll('.leaflet-tooltip').forEach(fixEl);
    },

    refreshRay(){
      if(!this.last){ this.ray?.setLatLngs([]); return; }
      const originLL = L.latLng(this.last.coords.latitude, this.last.coords.longitude);
      if(!this.originDot){ this.originDot=L.circleMarker(originLL,{radius:3,color:'#17f0c8',weight:2,fillColor:'#17f0c8',fillOpacity:1,interactive:false}).addTo(this.map); }
      else this.originDot.setLatLng(originLL).bringToFront();
      if(this.S.heading==null) return;
      if(!this.ray){ this.ray=L.polyline([], {color:'#17f0c8', weight:3, opacity:1, interactive:false}).addTo(this.map); }
      this.ray.setLatLngs([originLL, this._dest(originLL, this.S.heading, this._rayLen())]).bringToFront();
    },
    _rayLen(){ const s=this.map.getSize(); return Math.max(Math.hypot(s.x,s.y) * this._mpp() * 1.35 + 200, 3000); },
    _mpp(){ const s=this.map.getSize(); const a=this.map.containerPointToLatLng(L.point(s.x/2,s.y/2)); const b=this.map.containerPointToLatLng(L.point(s.x/2+1,s.y/2)); return this.map.distance(a,b)||1; },
    _dest(ll,b,dm){
      const br=R(b), dr=dm/6371000, lat1=R(ll.lat), lon1=R(ll.lng);
      const lat2=Math.asin(Math.sin(lat1)*Math.cos(dr)+Math.cos(lat1)*Math.sin(dr)*Math.cos(br));
      const lon2=lon1+Math.atan2(Math.sin(br)*Math.sin(dr)*Math.cos(lat1), Math.cos(dr)-Math.sin(lat1)*Math.sin(lat2));
      return L.latLng(Dg(lat2), Dg(lon2));
    },

    refreshNav(){
      if(!this.S.dest || !this.last){
        this.navLine?.setLatLngs([]); UI.setResetLabel('Reset'); return;
      }
      UI.setResetLabel('Clear Nav');
      const from = L.latLng(this.last.coords.latitude, this.last.coords.longitude);
      const to = L.latLng(this.S.dest.lat, this.S.dest.lng);
      if(!this.navLine){ this.navLine=L.polyline([], {color:'#2ac18a', weight:3, opacity:.95, interactive:false, dashArray:'6 6'}).addTo(this.map); }
      this.navLine.setLatLngs([from,to]).bringToFront();
      const b = bearing(from,to);
      const d = haversine(from,to);
      const err = this.S.heading==null ? null : Œî(this.S.heading,b);
      this._navState={ b, d, err };
      if(this.S.heading!=null){
        const on=Math.abs(err)<.5;
        this.navLine.setStyle(on ? {color:'#ff4444',weight:4,opacity:1}:{color:'#2ac18a',weight:3,opacity:.95});
      }
    },

    candidates(){
      const list=[]; Waypoints.markers.forEach((m,name)=>list.push({name, ll:m.getLatLng()}));
      if(Pins.pin){const ll=Pins.pin.getLatLng(); const nm=Pins.pin._nm||`Pin ${fix(ll.lat)},${fix(ll.lng)}`; list.push({name:nm, ll});}
      return list;
    },
    between(a,b,x){ const ab=Œî(a,b), ax=Œî(a,x); return Math.sign(ab)===Math.sign(ax) && Math.abs(ax)<=Math.abs(ab); },

    checkAnyAlignment(){
      const now=performance.now();
      if(!this.last || this.S.heading==null){
        this._pending=null;
        if(!(this._flashName && now < (this._flashUntil||0))){
          this._aligned=null; this._flashName=null; this._flashUntil=0; this._flashTarget=null;
          UI.setAlign('‚Äî'); UI.setNeedle(0);
        }
        return;
      }
      if(this._compassStartTs!=null && (now-this._compassStartTs) < this.WARMUP_MS) return;
      if(now - this._tAlign < 30) return; this._tAlign=now;

      const from=L.latLng(this.last.coords.latitude, this.last.coords.longitude);
      const head=this.S.heading;
      const prevHead=this._lastAlignHead ?? head;
      const movedLL=!this._lastAlignLL || this.map.distance(this._lastAlignLL, from) > 1.8;
      const movedHead=this._lastAlignHead==null || Math.abs(Œî(this._lastAlignHead, head)) > 0.06;
      if(!movedLL && !movedHead) return;
      this._lastAlignLL=from; this._lastAlignHead=head;

      const cand=this.candidates(); if(cand.length===0){ UI.setAlign('‚Äî'); return; }

      let instBest=null, instErr=Infinity, instDist=Infinity;
      for(const c of cand){
        const br=bearing(from,c.ll), err=Math.abs(Œî(head,br)), dist=haversine(from,c.ll);
        if(err < instErr - 1e-6 || (Math.abs(err-instErr) < 1e-6 && dist < instDist)){ instBest={...c, brg:br}; instErr=err; instDist=dist; }
      }

      const rayTarget=this._aligned || this._flashTarget || instBest;
      const rayErr = rayTarget ? Math.abs(Œî(head, bearing(from, rayTarget.ll))) : Infinity;
      UI.setNeedle(Œî(head, instBest?.brg ?? head));
      if(rayTarget && rayErr <= this.RAY.ACTIVE){ UI.flashPing(rayTarget.ll); }

      const step=Math.abs(Œî(prevHead,head));
      const dwell=Math.max(0, this.ALIGN.DWELL_BASE - 0.6*(this.S.omega || 0));
      const enter=this.ALIGN.ENTER, exit=this.ALIGN.EXIT;

      if(this._aligned){
        const e=Math.abs(Œî(head, bearing(from,this._aligned.ll)));
        if(e <= exit){ UI.setAlign(this._aligned.name); return; }
        this._aligned=null;
      }

      if(instBest && instErr <= enter){
        if(this._pending && this._pending.name===instBest.name){
          if(now - this._pending.since >= dwell){
            this._aligned={name:instBest.name, ll:instBest.ll, err:instErr, dist:instDist};
            this._pending=null; this._flashName=null; this._flashUntil=0; this._flashTarget=null;
            UI.setAlign(this._aligned.name, true);
            UI.flashPing(this._aligned.ll, true);
          }
        }else{
          this._pending={name:instBest.name, since:now};
        }
      }else{
        this._pending=null;
      }

      // scanning flash if swept over
      let flashPick=null, flashErr=Infinity;
      if(step <= 35){
        for(const c of cand){
          const br=bearing(from,c.ll);
          if(this.between(prevHead, head, br)){
            const e=Math.abs(Œî(head, br));
            if(e < flashErr){ flashErr=e; flashPick=c; }
          }
        }
      }
      if(flashPick){
        const lastFire=this._flashCooldown.get(flashPick.name) || 0;
        if(now - lastFire > this.SCAN.COOLDOWN){
          this._flashCooldown.set(flashPick.name, now);
          this._flashName=flashPick.name; this._flashUntil=now+this.SCAN.FLASH; this._flashTarget={name:flashPick.name, ll:flashPick.ll};
          UI.setAlign(flashPick.name, false, true); UI.flashPing(flashPick.ll);
        }
      }
      if(this._flashName && now > this._flashUntil){
        this._flashName=null; this._flashUntil=0; this._flashTarget=null; UI.setAlign('‚Äî');
      }
    },

    updateHUD(){
      const now=performance.now(); if(now - this._tHUD < 120) return; this._tHUD=now;
      $('hudLat').textContent = this.last?.coords?.latitude?.toFixed(6) ?? '‚Äî';
      $('hudLng').textContent = this.last?.coords?.longitude?.toFixed(6) ?? '‚Äî';
      $('hudAcc').textContent = (this.last?.coords?.accuracy ? Math.round(this.last.coords.accuracy) : '‚Äî') + ' m';
      $('hudHead').textContent = this.S.heading!=null ? this.S.heading.toFixed(2)+'¬∞' : '‚Äî¬∞';
      $('hudMap').textContent  = N(-this.S.bearing).toFixed(2)+'¬∞';
      if(this.S.dest && this.last){
        const from=L.latLng(this.last.coords.latitude, this.last.coords.longitude);
        const to=L.latLng(this.S.dest.lat, this.S.dest.lng);
        const b=bearing(from,to); const d=haversine(from,to);
        const steer = (this.S.heading!=null) ? Œî(this.S.heading,b).toFixed(2) : '‚Äî';
        $('hudAlign').textContent = `${this.S.dest.name||'Dest'}  ${fmtDist(d)}  brg ${b.toFixed(1)}¬∞  Œî ${steer}¬∞`;
      } else {
        $('hudAlign').textContent = '‚Äî';
      }
    },

    loop(){
      const tgt = (this.S.rotate ?? false) ? (this.S.heading ?? 0) : 0;
      const err = Math.abs(Œî(this.S.bearing, tgt));
      const aRot = 0.12 + 0.38 * Math.min(1, (this.S.omega || 0) / 240);
      this.S.bearing = err < 0.08 ? this.S.bearing : blend(this.S.bearing, tgt, aRot);

      this.applyBearing(this.S.bearing);
      this.refreshRay();

      const now=performance.now();
      if(now - this._tNav > 60){ this._tNav=now; this.refreshNav(); }
      this.checkAnyAlignment();
      this.updateHUD();

      requestAnimationFrame(()=>this.loop());
    },

    _setHeadingFromOrient(){
      const e=this._lastOrientEvent; if(!e) return;
      let heading=null;
      if (typeof e.webkitCompassHeading === 'number' && Number.isFinite(e.webkitCompassHeading)) {
        heading=e.webkitCompassHeading;
      } else if (typeof e.alpha === 'number' && Number.isFinite(e.alpha)) {
        const flip = 360 - e.alpha;
        const ang  = getScreenAngle();
        heading = (flip + ang) % 360;
      } else return;

      if (isAndroid() && ($('invertAndroid')?.checked)) heading = (360 - heading) % 360;
      heading = (heading + (this.S.decl || 0)) % 360; if (heading<0) heading += 360;

      if (this._compassStartTs==null) this._compassStartTs=performance.now();
      if (this.S.heading==null) this.S.heading=heading;
      else {
        const diff=((heading - this.S.heading + 540)%360)-180;
        if (Math.abs(diff) >= this.DEAD_ZONE) {
          const step=Math.sign(diff) * Math.min(Math.abs(diff), this.MAX_STEP);
          this.S.heading = (this.S.heading + step + 360) % 360;
        }
      }
      this.S.mag = e.alpha ?? null;
    },

    onOrient(e){
      if (e.absolute===true || e.type==='deviceorientationabsolute' || typeof e.webkitCompassHeading==='number')
        this._lastOrientEvent=e;
      else if (!this._lastOrientEvent) this._lastOrientEvent=e;
      this._setHeadingFromOrient();
    },

    async enableCompass(){
      if(this.S.compass) return true;
      try{
        if(location.protocol!=='https:' && location.hostname!=='localhost'){ toast('Compass requires HTTPS.'); return false; }
        if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
          const perm=await DeviceOrientationEvent.requestPermission(); if(perm!=='granted'){ toast('Compass permission denied.'); return false; }
        }
        if(!this._compassBound){
          addEventListener('deviceorientationabsolute', e=>this.onOrient(e), true);
          addEventListener('deviceorientation', e=>this.onOrient(e), true);
          this._compassBound=true;
        }
        this.S.compass=true; return true;
      }catch(err){ toast('Compass access failed.'); console.error(err); return false; }
    },

    startGPS(){
      if(!('geolocation' in navigator)){ toast('Geolocation not supported.'); return; }
      if(this.watchId!=null) return;
      let prev=null;
      this.watchId = navigator.geolocation.watchPosition(p=>{
        const old=prev; prev=p; this.last=p;
        const { latitude, longitude, accuracy } = p.coords;
        this.accCircle.setLatLng([latitude,longitude]).setRadius(Math.max(accuracy||0,0));
        if(this.S.follow){ this.map.setView([latitude,longitude], Math.max(this.map.getZoom(),16), {animate:false}); }
        if(old && Number.isFinite(p.coords.speed) && p.coords.speed>=1 && this.S.rotate && this.S.heading==null){
          const prevLL=L.latLng(old.coords.latitude, old.coords.longitude);
          const currLL=L.latLng(p.coords.latitude, p.coords.longitude);
          this.S.heading=bearing(prevLL,currLL);
        }
      }, e=>{ toast('Unable to get location: '+e.message); console.error(e); },{
        enableHighAccuracy:true, maximumAge:2000, timeout:15000
      });
    },

    stopGPS(){ if(this.watchId!=null && 'geolocation' in navigator){ navigator.geolocation.clearWatch(this.watchId); this.watchId=null; } },

    resetView(){
      if(this.S.dest){ this.S.dest=null; this.refreshNav(); UI.updateHUD(); return; }
      if(this.last){ const {latitude,longitude} = this.last.coords; this.map.setView([latitude,longitude], Math.max(this.map.getZoom(),16)); }
      else this.map.setView([this.DEF.lat,this.DEF.lng], this.DEF.z);
      this.applyBearing(this.S.bearing);
    }
  };

  const UI = {
    sync(S){ $('btnGPS')?.classList.toggle('glow', !!App.last); $('btnRotate')?.classList.toggle('glow', !!S.rotate); },
    setResetLabel(t){ $('btnReset').textContent = '‚Ü∫ '+t; },
    declInit(v){ $('declSlider').value=String(v); $('declVal').textContent=`${(+v).toFixed(1)}¬∞`; },
    setAlign(name){ $('hudAlign').textContent = name || '‚Äî'; },
    setNeedle(delta){ const clamped=Math.max(-45, Math.min(45, delta)); document.documentElement.style.setProperty('--err', clamped+'deg'); },
    flashPing(ll){
      try{
        const pt=App.map.latLngToContainerPoint(ll);
        const mini = document.querySelector('.map-wrap');
        const el=document.createElement('div');
        el.className='ping flash';
        el.style.left = pt.x + 'px'; el.style.top = pt.y + 'px';
        mini.appendChild(el);
        setTimeout(()=>el.remove(), 700);
      }catch{}
    },
    updateHUD(){ App.updateHUD(); }
  };

  const Waypoints = {
    markers:new Map(),
    init(){ this.render(); this.syncMarkers(); },
    load(){ return Store.loadWPs(); },
    save(a){ Store.saveWPs(a); },
    ensureMarker(name){ return this.markers.get(name) || null; },
    render(){
      const el=$('wpList'); if(!el) return; el.innerHTML='';
      const a=this.load();
      a.forEach((w,i)=>{
        const row=document.createElement('div');
        row.style.display='grid'; row.style.gridTemplateColumns='1fr auto auto'; row.style.gap='6px'; row.style.alignItems='center';
        row.style.padding='6px'; row.style.borderBottom='1px solid var(--line)';
        row.innerHTML=`<div><b>${w.name}</b><br/><small style="color:var(--muted)">${w.lat.toFixed(6)}, ${w.lng.toFixed(6)}</small></div>
          <button class="btn small" data-idx="${i}" data-go>Go</button>
          <button class="btn small" data-idx="${i}" data-guide>Guide</button>
          <button class="btn small" style="grid-column:3/4;margin-top:6px" data-idx="${i}" data-del>Del</button>`;
        el.appendChild(row);
      });
    },
    upsert(name,lat,lng){
      const a=this.load();
      const nm=(name?.trim()) || `WP ${Date.now().toString().slice(-5)}`;
      const i=a.findIndex(w=>w.name.toLowerCase()===nm.toLowerCase());
      const e={name:nm,lat,lng}; if(i>=0) a[i]=e; else a.push(e);
      this.save(a); this.render(); this.syncMarkers();
    },
    del(i){
      const a=this.load(); const [rm]=a.splice(i,1); this.save(a); this.render();
      if(rm && this.markers.has(rm.name)){ App.map.removeLayer(this.markers.get(rm.name)); this.markers.delete(rm.name); }
    },
    syncMarkers(){
      const a=this.load();
      a.forEach(w=>{
        if(!this.markers.has(w.name)){
          const m=makeDot(w.lat,w.lng,10).addTo(App.map);
          bindMarker(m, { name:w.name, lat:w.lat, lng:w.lng });
          this.markers.set(w.name,m);
        }else{
          const m=this.markers.get(w.name);
          m.setLatLng([w.lat,w.lng]).setIcon(DotIcon(10));
          bindMarker(m, { name:w.name, lat:w.lat, lng:w.lng });
        }
      });
      Array.from(this.markers.keys()).forEach(n=>{
        if(!this.load().some(w=>w.name===n)){ App.map.removeLayer(this.markers.get(n)); this.markers.delete(n); }
      });
    }
  };

  const Pins = {
    pin:null,_nm:null,
    drop(lat,lng){
      if(this.pin) App.map.removeLayer(this.pin);
      this.pin=makeDot(lat,lng,12).addTo(App.map);
      this._nm=`Pin ${fix(lat)},${fix(lng)}`;
      bindMarker(this.pin, { name:this._nm, lat, lng });
      this.pin.openPopup();
      App.uprightOverlays(App.S.bearing);
    }
  };

  function parseCoords(t){
    const s=t.trim().replace(/\s+/g,' ').replace(/[,;]+/g,',');
    const m=s.match(/^\s*([+-]?\d+(\.\d+)?)\s*,\s*([+-]?\d+(\.\d+)?)\s*$/i);
    if(m){ const lat=+m[1], lng=+m[3]; if(isFinite(lat)&&isFinite(lng)&&Math.abs(lat)<=90&&Math.abs(lng)<=180) return {lat,lng}; }
    const parts=s.split(','); if(parts.length===2){
      const one=q=>{ const x=q.trim().match(/^([NSEW])?\s*([+-]?\d+(\.\d+)?)\s*([NSEW])?$/i); if(!x) return null;
        const h=(x[1]||x[4]||'').toUpperCase(); let v=parseFloat(x[2]);
        if(h==='S'||h==='W') v=-Math.abs(v); if(h==='N'||h==='E') v=Math.abs(v); return {v,h}; };
      const a=one(parts[0]), b=one(parts[1]);
      if(a&&b){ const lat=(a.h==='N'||a.h==='S')?a.v:b.v; const lng=(a.h==='E'||a.h==='W')?a.v:b.v;
        if(Math.abs(lat)<=90&&Math.abs(lng)<=180) return {lat,lng}; }
    }
    return null;
  }

  function bindMarker(m,{name,lat,lng}){
    m.unbindPopup();
    m.bindPopup(()=>{
      return `<div style="display:grid;gap:8px">
        <input type="text" value="${name || `Pin ${fix(lat)},${fix(lng)}`}" data-name
          style="padding:8px;border-radius:8px;border:1px solid var(--line);background:rgba(255,255,255,.05);color:var(--ink)"/>
        <div style="color:var(--muted);font-size:12px">${fix(lat)}, ${fix(lng)}</div>
        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button class="btn small" data-copy>Copy</button>
          <button class="btn small" data-min>Min</button>
          <button class="btn small" data-guide>Guide</button>
          <button class="btn small glow" data-save>Save</button>
        </div>
      </div>`;
    }, { className:'floating-popup', autoClose:true, closeButton:true, offset:[0,-10] })
    .off('popupopen').on('popupopen', ()=>{
      const el=m.getPopup().getElement(); if(!el) return;
      const I=el.querySelector('[data-name]'), C=el.querySelector('[data-copy]'),
            SAV=el.querySelector('[data-save]'), MIN=el.querySelector('[data-min]'), G=el.querySelector('[data-guide]');
      C?.addEventListener('click', async ()=>{
        const txt=`${fix(lat)}, ${fix(lng)}`;
        try{ await navigator.clipboard.writeText(txt); C.textContent='Copied'; setTimeout(()=>C.textContent='Copy',900); }
        catch{ prompt('Copy to clipboard:', txt); }
      });
      SAV?.addEventListener('click', ()=>{ const nm=(I?.value||'').trim()||`WP ${Date.now().toString().slice(-5)}`; Waypoints.upsert(nm,lat,lng); m.closePopup(); m._nm=nm; });
      MIN?.addEventListener('click', ()=>{
        const nm=(I?.value || m._nm || 'Pin') || 'Pin';
        m.bindTooltip(nm, { permanent:true, direction:'right', offset:[8,0], className:'mini leaflet-tooltip mini' }).openTooltip();
        m.closePopup(); m._nm=nm; App.uprightOverlays(App.S.bearing);
      });
      G?.addEventListener('click', ()=>{ App.S.dest={lat,lng,name:(I?.value || m._nm || 'Dest')}; App.refreshNav(); UI.updateHUD(); m.closePopup(); });
      App.uprightOverlays(App.S.bearing);
    });
    m.on('tooltipopen', ()=>App.uprightOverlays(App.S.bearing));
  }

  ready(()=>{
    try{
      if(!window.L){ toast('Leaflet failed to load.'); return; }
      App.init(); Waypoints.init();
    }catch(err){
      console.error(err);
      toast((err && err.message) ? err.message : String(err));
    }
  });
})();
</script>
</body>
</html>
