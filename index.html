<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Map App ‚Äî Laser Align (Rewrite)</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin="anonymous"
  />
  <style>
    :root {
      --bg: #0f1416;
      --panel: #1c2426;
      --text: #e9f2ed;
      --accent: #3bb67c;
      --dim: #8fae9f;
      --danger: #ff5e5e;
    }
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    #map {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }
    /* Controls bar */
    .controls {
      position: fixed;
      top: env(safe-area-inset-top, 12px);
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      background: var(--panel);
      padding: 8px 12px;
      border-radius: 12px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
      z-index: 1000;
    }
    .btn {
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.07), rgba(255, 255, 255, 0.02));
      color: var(--text);
      padding: 8px 12px;
      border-radius: 9px;
      font: 500 14px/1 system-ui, sans-serif;
      cursor: pointer;
    }
    .btn.primary {
      border-color: var(--accent);
    }
    .btn.toggled {
      outline: 2px solid var(--accent);
    }
    .badge {
      margin-left: 6px;
      padding: 0 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 999px;
      font-size: 12px;
    }
    .fab {
      position: fixed;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.15);
      z-index: 1000;
      cursor: pointer;
    }
    .fab.wp {
      bottom: calc(env(safe-area-inset-bottom, 14px) + 60px);
      right: 14px;
    }
    .fab.gear {
      bottom: calc(env(safe-area-inset-bottom, 14px) + 8px);
      right: 14px;
    }
    .panel {
      position: fixed;
      bottom: calc(env(safe-area-inset-bottom, 12px) + 120px);
      right: 12px;
      width: min(92vw, 350px);
      max-height: 60vh;
      overflow-y: auto;
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.45);
      z-index: 900;
      display: none;
    }
    .panel.open {
      display: block;
    }
    .row {
      display: grid;
      gap: 8px;
      margin-bottom: 12px;
    }
    .row input,
    .row button {
      width: 100%;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      font: 500 14px/1.2 system-ui, sans-serif;
    }
    .list {
      display: grid;
      gap: 8px;
    }
    .item {
      display: grid;
      grid-template-columns: 1fr auto auto auto auto;
      align-items: center;
      gap: 6px;
      padding: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
    }
    .item small {
      color: var(--dim);
      display: block;
    }
    .item button {
      padding: 6px 10px;
      font-size: 13px;
    }
    .danger {
      border-color: var(--danger);
      color: var(--danger);
    }
    /* HUD */
    .info {
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: env(safe-area-inset-bottom, 12px);
      background: rgba(28, 36, 38, 0.9);
      padding: 12px;
      border-radius: 14px;
      font: 500 13px/1.25 ui-monospace, Menlo, monospace;
      color: var(--dim);
      z-index: 800;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(4px);
      pointer-events: none;
    }
    .info .metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 18px;
    }
    .info .metric {
      display: flex;
      gap: 6px;
      align-items: baseline;
    }
    .info .metric span {
      color: var(--dim);
      font: 600 12px system-ui, sans-serif;
    }
    .info .value {
      color: var(--text);
      font: 700 15px ui-monospace;
      letter-spacing: 0.2px;
    }
    /* Popup overrides */
    .leaflet-popup-content {
      font: 500 13px/1.3 system-ui, sans-serif;
      color: var(--text);
    }
    .floating-popup .leaflet-popup-content-wrapper {
      background: rgba(28, 36, 38, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.45);
    }
    .floating-popup .leaflet-popup-tip {
      background: rgba(28, 36, 38, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
    .floating-popup .leaflet-popup-content {
      margin: 10px 12px;
    }
    .popup-grid {
      display: grid;
      gap: 8px;
    }
    .popup-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    .popup-input {
      width: 100%;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      font: 500 13px system-ui, sans-serif;
    }
    .mini-label {
      background: rgba(28, 36, 38, 0.9);
      color: var(--text);
      padding: 2px 6px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 8px;
      font: 600 12px system-ui, sans-serif;
      backdrop-filter: blur(4px);
      pointer-events: none;
    }
    .align-banner {
      position: fixed;
      top: calc(env(safe-area-inset-top, 12px) + 60px);
      left: 50%;
      transform: translateX(-50%);
      background: rgba(28, 36, 38, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 8px 12px;
      font: 600 13px system-ui, sans-serif;
      color: var(--text);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(4px);
      z-index: 950;
      display: none;
    }
    .align-banner.show {
      display: block;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="controls" role="toolbar" aria-label="Map controls">
    <button id="btnLocate" class="btn primary">Enable GPS</button>
    <button id="btnFollow" class="btn toggled" aria-pressed="true">
      Follow: <span id="followState" class="badge">on</span>
    </button>
    <button id="btnCompass" class="btn" aria-pressed="false">
      Rotate <span id="compassState" class="badge">off</span>
    </button>
    <button id="btnReset" class="btn">Reset</button>
  </div>

  <div id="alignBanner" class="align-banner" aria-live="polite">
    Aligned: <b id="alignName">‚Äî</b>
  </div>

  <button id="btnWaypoints" class="btn fab wp" title="Waypoints">üìç</button>
  <button id="btnSettings" class="btn fab gear" title="Settings">‚öôÔ∏è</button>

  <div id="wpPanel" class="panel" aria-hidden="true">
    <div class="row">
      <input id="wpName" placeholder="Name (e.g., Tower SE)" aria-label="Waypoint name" />
      <input id="wpCoords" placeholder="34.851939 N, -119.168399 W" aria-label="Coordinates" />
      <button id="wpAdd" class="btn primary">Add / Update</button>
    </div>
    <div class="list" id="wpList" aria-live="polite"></div>
  </div>

  <div id="settingsPanel" class="panel" aria-hidden="true">
    <div class="settings-group">
      <div class="settings-label">Declination Offset</div>
      <input id="declSlider" type="range" min="-30" max="30" step="0.1" aria-label="Declination slider" />
      <div class="settings-note">
        True heading = Magnetic + <span id="declVal" class="settings-value">0.0¬∞</span>
      </div>
      <button id="declSave" class="btn primary">Save</button>
    </div>
  </div>

  <div class="info" id="readout">
    <div class="metrics"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <script>
    // Rewritten (modular) version
    document.addEventListener("DOMContentLoaded", () => {
      const $ = (id) => document.getElementById(id);

      // Helper math and geo functions
      const toRad = (d) => (d * Math.PI) / 180;
      const toDeg = (r) => (r * 180) / Math.PI;
      const norm360 = (v) => ((v % 360) + 360) % 360;
      const deltaAng = (a, b) => {
        let d = norm360(b) - norm360(a);
        if (d > 180) d -= 360;
        if (d < -180) d += 360;
        return d;
      };

      function haversine(a, b) {
        const R = 6371000;
        const œÜ1 = toRad(a.lat);
        const œÜ2 = toRad(b.lat);
        const dœÜ = toRad(b.lat - a.lat);
        const dŒª = toRad(b.lng - a.lng);
        const s =
          Math.sin(dœÜ / 2) * Math.sin(dœÜ / 2) +
          Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(dŒª / 2) * Math.sin(dŒª / 2);
        return 2 * R * Math.asin(Math.min(1, Math.sqrt(s)));
      }

      function bearing(a, b) {
        const œÜ1 = toRad(a.lat),
          œÜ2 = toRad(b.lat),
          Œª1 = toRad(a.lng),
          Œª2 = toRad(b.lng);
        const y = Math.sin(Œª2 - Œª1) * Math.cos(œÜ2);
        const x =
          Math.cos(œÜ1) * Math.sin(œÜ2) -
          Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(Œª2 - Œª1);
        return norm360(toDeg(Math.atan2(y, x)));
      }

      function distStr(m) {
        return m < 1000 ? `${Math.round(m)} m` : `${(m / 1000).toFixed(2)} km`;
      }

      function createDotMarker(lat, lng, size = 12) {
        return L.marker([lat, lng], {
          icon: L.divIcon({
            className: "dot-pin",
            iconSize: [size, size],
            iconAnchor: [size / 2, size / 2],
          }),
          riseOnHover: true,
        });
      }

      function parseCoords(input) {
        input = input.trim().replace(/\s+/g, " ").replace(/[,;]+/g, ",");
        // Simple decimal-decimal format
        const m = input.match(
          /^\s*([+-]?\d+(\.\d+)?)\s*,\s*([+-]?\d+(\.\d+)?)\s*$/i
        );
        if (m) {
          const lat = parseFloat(m[1]);
          const lng = parseFloat(m[3]);
          if (Math.abs(lat) <= 90 && Math.abs(lng) <= 180)
            return { lat, lng };
        }
        // Try DMS/NSEW combos
        const parts = input.split(",");
        if (parts.length === 2) {
          const parsePart = (str) => {
            const mm = str
              .trim()
              .match(/^([NSEW])?\s*([+-]?\d+(\.\d+)?)\s*([NSEW])?$/i);
            if (!mm) return null;
            const h1 = (mm[1] || mm[4] || "").toUpperCase();
            let v = parseFloat(mm[2]);
            if (h1 === "S" || h1 === "W") v = -Math.abs(v);
            return { v, h1 };
          };
          const A = parsePart(parts[0]);
          const B = parsePart(parts[1]);
          if (A && B) {
            let lat, lng;
            if (A.h1 === "N" || A.h1 === "S") lat = A.v;
            else lng = A.v;
            if (B.h1 === "N" || B.h1 === "S") lat = B.v;
            else lng = B.v;
            if (
              lat != null &&
              lng != null &&
              Math.abs(lat) <= 90 &&
              Math.abs(lng) <= 180
            )
              return { lat, lng };
          }
        }
        return null;
      }

      // State & Modules
      const State = {
        follow: true,
        rotate: true,
        bearing: 0,
        heading: null,
        decl: 0,
        omega: 0,
        mag: null,
        dest: null,
        watchId: null,
        aligned: null,
        pending: null,
        flash: { name: null, until: 0, target: null },
        lastHeadTs: null,
        prevHead: null,
        lastAbsTs: 0,
      };

      const Config = {
        ALIGN: {
          ENTER: 0.35,
          EXIT: 0.6,
          DWELL_BASE: 60,
        },
        SCAN: {
          FLASH: 500,
          COOLDOWN: 600,
        },
        RAY_ACTIVE_THRESH: 0.15,
      };

      let map, accCircle, originDot, rayLine, navLine;

      const Waypoints = {
        key: "mapapp.wps.v2",
        list: [],
        markers: new Map(),

        load() {
          try {
            this.list = JSON.parse(localStorage.getItem(this.key) || "[]");
          } catch (e) {
            this.list = [];
          }
        },
        save() {
          localStorage.setItem(this.key, JSON.stringify(this.list));
        },
        syncMarkers() {
          this.markers.forEach((m) => map.removeLayer(m));
          this.markers.clear();
          this.list.forEach((w) => {
            const m = createDotMarker(w.lat, w.lng, 12).addTo(map);
            this.bindPopup(m, w);
            this.markers.set(w.name, m);
          });
        },
        renderListUI() {
          const container = $("wpList");
          container.innerHTML = "";
          this.list.forEach((w, i) => {
            const div = document.createElement("div");
            div.className = "item";
            div.innerHTML = `
              <div>
                <strong>${w.name}</strong>
                <small>${w.lat.toFixed(6)}, ${w.lng.toFixed(6)}</small>
              </div>
              <button data-idx="${i}" data-go>Go</button>
              <button data-idx="${i}" data-guide>Guide</button>
              <button data-idx="${i}" data-edit>Edit</button>
              <button data-idx="${i}" data-del class="danger">Del</button>
            `;
            container.appendChild(div);
          });
        },
        bindPopup(marker, w) {
          marker.unbindPopup();
          marker.bindPopup(this.makePopupHTML(w), { className: "floating-popup", offset: [0, -10] });
          marker.on("popupopen", () => {
            const el = marker.getPopup().getElement();
            const inp = el.querySelector("[data-name]");
            const btnCopy = el.querySelector("[data-copy]");
            const btnSave = el.querySelector("[data-save]");
            const btnMin = el.querySelector("[data-min]");
            const btnGuide = el.querySelector("[data-guide]");

            btnCopy?.addEventListener("click", async () => {
              const txt = `${w.lat.toFixed(6)}, ${w.lng.toFixed(6)}`;
              try {
                await navigator.clipboard.writeText(txt);
                btnCopy.textContent = "Copied";
                setTimeout(() => (btnCopy.textContent = "Copy"), 900);
              } catch {
                prompt("Copy to clipboard:", txt);
              }
            });
            btnMin?.addEventListener("click", () => {
              marker.bindTooltip(w.name, {
                permanent: true,
                direction: "right",
                offset: [8, 0],
                className: "mini-label",
              }).openTooltip();
              marker.closePopup();
            });
            btnSave?.addEventListener("click", () => {
              const newName = inp.value.trim() || w.name;
              w.name = newName;
              this.save();
              this.renderListUI();
              this.syncMarkers();
              marker.closePopup();
            });
            btnGuide?.addEventListener("click", () => {
              State.dest = { lat: w.lat, lng: w.lng, name: w.name };
              refreshNavLine();
              updateHUD();
              marker.closePopup();
            });
          });
        },
        makePopupHTML(w) {
          return `
            <div class="popup-grid">
              <input class="popup-input" type="text" placeholder="Name" value="${w.name}" data-name />
              <div style="color: var(--dim); font-size: 12px;">
                ${w.lat.toFixed(6)}, ${w.lng.toFixed(6)}
              </div>
              <div class="popup-actions">
                <button class="btn" data-copy>Copy</button>
                <button class="btn" data-min>Minimize</button>
                <button class="btn" data-guide>Guide</button>
                <button class="btn primary" data-save>Save</button>
              </div>
            </div>
          `;
        },
        addOrUpdate(name, lat, lng) {
          const nm = name.trim() || `WP ${Date.now().toString().slice(-5)}`;
          const idx = this.list.findIndex((w) => w.name.toLowerCase() === nm.toLowerCase());
          const ent = { name: nm, lat, lng };
          if (idx >= 0) this.list[idx] = ent;
          else this.list.push(ent);
          this.save();
          this.renderListUI();
          this.syncMarkers();
        },
        delete(i) {
          this.list.splice(i, 1);
          this.save();
          this.renderListUI();
          this.syncMarkers();
        },
        edit(i) {
          const w = this.list[i];
          const container = $("wpList");
          const el = container.children[i];
          if (!el) return;
          el.innerHTML = `
            <div style="display: grid; gap: 6px">
              <input data-e-name placeholder="Name" value="${w.name}" />
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px">
                <input data-e-lat placeholder="Lat" value="${w.lat.toFixed(6)}" />
                <input data-e-lng placeholder="Lng" value="${w.lng.toFixed(6)}" />
              </div>
            </div>
            <button class="btn primary" data-idx="${i}" data-save-edit>Save</button>
            <button class="btn" data-idx="${i}" data-cancel>Cancel</button>
          `;
        },
        saveEdit(i) {
          const w = this.list[i];
          const container = $("wpList");
          const el = container.children[i];
          if (!el) return;
          const nameIn = el.querySelector("[data-e-name]").value.trim() || w.name;
          const latIn = parseFloat(el.querySelector("[data-e-lat]").value);
          const lngIn = parseFloat(el.querySelector("[data-e-lng]").value);
          if (
            !isFinite(latIn) ||
            !isFinite(lngIn) ||
            Math.abs(latIn) > 90 ||
            Math.abs(lngIn) > 180
          ) {
            alert("Invalid coordinates");
            return;
          }
          w.name = nameIn;
          w.lat = latIn;
          w.lng = lngIn;
          this.save();
          this.renderListUI();
          this.syncMarkers();
        },
      };

      const Pins = {
        pinMarker: null,
        currentName: null,
        drop(lat, lng) {
          if (this.pinMarker) map.removeLayer(this.pinMarker);
          this.pinMarker = createDotMarker(lat, lng, 14).addTo(map);
          this.currentName = `Pin ${lat.toFixed(6)},${lng.toFixed(6)}`;
          Waypoints.bindPopup(this.pinMarker, {
            name: this.currentName,
            lat,
            lng,
          });
          this.pinMarker.openPopup();
        },
      };

      // Initialize map and base layers
      function initMap() {
        map = L.map("map", { zoomControl: true, attributionControl: true });
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 20,
          minZoom: 2,
          attribution: "¬© OpenStreetMap",
        }).addTo(map);

        map.setView([34.9, -119.17], 16);
        accCircle = L.circle([34.9, -119.17], { radius: 10, color: "#4db6ff", weight: 1, opacity: 0.6, fillOpacity: 0.1 }).addTo(map);
      }

      function bindUIEvents() {
        $("btnLocate").onclick = startGPS;
        $("btnFollow").onclick = () => {
          State.follow = !State.follow;
          $("followState").textContent = State.follow ? "on" : "off";
          $("btnFollow").classList.toggle("toggled", State.follow);
          $("btnFollow").setAttribute("aria-pressed", String(State.follow));
          if (State.follow && State.lastPos) {
            map.setView([State.lastPos.latitude, State.lastPos.longitude], Math.max(map.getZoom(), 16));
          }
        };
        $("btnCompass").onclick = async () => {
          if (!State.rotate) {
            const ok = await enableCompass();
            if (!ok) return;
            State.rotate = true;
          } else {
            State.rotate = false;
          }
          $("compassState").textContent = State.rotate ? "on" : "off";
          $("btnCompass").classList.toggle("toggled", State.rotate);
          $("btnCompass").setAttribute("aria-pressed", String(State.rotate));
        };
        $("btnReset").onclick = () => {
          if (State.dest) {
            State.dest = null;
            updateHUD();
            refreshNavLine();
            return;
          }
          if (State.lastPos) {
            map.setView([State.lastPos.latitude, State.lastPos.longitude], Math.max(map.getZoom(), 16));
          } else {
            map.setView([34.9, -119.17], 16);
          }
        };

        const btnWP = $("btnWaypoints"),
          wpPanel = $("wpPanel");
        btnWP.onclick = () => {
          const open = !wpPanel.classList.contains("open");
          wpPanel.classList.toggle("open", open);
          wpPanel.setAttribute("aria-hidden", String(!open));
        };
        $("wpAdd").onclick = () => {
          const p = parseCoords($("wpCoords").value);
          if (!p) return alert("Could not parse coordinates");
          Waypoints.addOrUpdate($("wpName").value, p.lat, p.lng);
          $("wpName").value = "";
          $("wpCoords").value = "";
        };
        $("wpList").onclick = (e) => {
          const btn = e.target;
          const idx = btn.getAttribute("data-idx");
          if (idx == null) return;
          const i = parseInt(idx);
          if (btn.hasAttribute("data-go")) {
            const w = Waypoints.list[i];
            State.rotate = false;
            State.follow = false;
            $("compassState").textContent = State.rotate ? "on" : "off";
            $("btnCompass").classList.toggle("toggled", State.rotate);
            $("btnFollow").classList.toggle("toggled", State.follow);
            $("followState").textContent = State.follow ? "on" : "off";
            map.setView([w.lat, w.lng], 16);
            Waypoints.markers.get(w.name).openPopup();
          } else if (btn.hasAttribute("data-guide")) {
            const w = Waypoints.list[i];
            State.dest = { lat: w.lat, lng: w.lng, name: w.name };
            refreshNavLine();
            updateHUD();
          } else if (btn.hasAttribute("data-edit")) {
            Waypoints.edit(i);
          } else if (btn.hasAttribute("data-save-edit")) {
            Waypoints.saveEdit(i);
          } else if (btn.hasAttribute("data-cancel")) {
            Waypoints.renderListUI();
          } else if (btn.hasAttribute("data-del")) {
            Waypoints.delete(i);
          }
        };

        const btnSettings = $("btnSettings"),
          settings = $("settingsPanel");
        btnSettings.onclick = () => {
          const open = !settings.classList.contains("open");
          settings.classList.toggle("open", open);
          settings.setAttribute("aria-hidden", String(!open));
        };
        const slider = $("declSlider"),
          val = $("declVal");
        const showVal = () => {
          const v = parseFloat(slider.value);
          val.textContent = `${v.toFixed(1)}¬∞`;
        };
        slider.addEventListener(
          "input",
          () => {
            const v = parseFloat(slider.value);
            if (isFinite(v)) {
              State.decl = v;
              showVal();
            }
          },
          { passive: true }
        );
        $("declSave").onclick = () => {
          const v = parseFloat(slider.value);
          if (isFinite(v)) {
            State.decl = v;
            if (State.mag != null) {
              State.heading = norm360(State.mag + State.decl);
            }
            localStorage.setItem("mapapp.state.v2", JSON.stringify({
              decl: State.decl,
              rotate: State.rotate,
              follow: State.follow,
            }));
            updateHUD();
            const btn = $("declSave");
            const txtOld = btn.textContent;
            btn.textContent = "Saved ‚úì";
            setTimeout(() => (btn.textContent = txtOld), 900);
          }
        };
        showVal();
      }

      function bindMapInteractions() {
        const container = map.getContainer();
        let timer = null;
        let startPt = null;
        let lastPt = null;
        const LONGPRESS = 400;
        const MOVE_THRESHOLD = 6;

        const getPt = (ev) => {
          const r = container.getBoundingClientRect();
          return L.point(ev.clientX - r.left, ev.clientY - r.top);
        };

        const onPress = (ev) => {
          if (ev.button !== 0 && ev.pointerType === "mouse") return;
          ev.preventDefault();
          timer = setTimeout(() => {
            timer = null;
            const p = lastPt ?? startPt;
            const ll = map.containerPointToLatLng(p);
            Pins.drop(ll.lat, ll.lng);
          }, LONGPRESS);
          startPt = lastPt = getPt(ev);
        };
        const onMove = (ev) => {
          if (!timer) return;
          ev.preventDefault();
          lastPt = getPt(ev);
          if (startPt.distanceTo(lastPt) > MOVE_THRESHOLD) {
            clearTimeout(timer);
            timer = null;
          }
        };
        const onUp = () => {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        };

        container.addEventListener("pointerdown", onPress, { passive: false });
        container.addEventListener("pointermove", onMove, { passive: false });
        container.addEventListener("pointerup", onUp, { passive: true });
        container.addEventListener("pointercancel", onUp, { passive: true });

        map.on("contextmenu", (ev) => {
          ev.originalEvent.preventDefault();
          const ll = ev.latlng;
          Pins.drop(ll.lat, ll.lng);
        });

        map.on("move moveend zoom zoomend zoomanim", () => {
          applyMapRotation(State.bearing);
          refreshRay();
        });

        window.addEventListener("resize", () => {
          map.invalidateSize();
          applyMapRotation(State.bearing);
          refreshRay();
        });
      }

      function applyMapRotation(deg) {
        const pane = map.getPane("mapPane");
        if (!pane) return;
        // pivot at user location if available
        let origin = "50% 50%";
        if (State.lastPos) {
          const pt = map.latLngToContainerPoint([
            State.lastPos.latitude,
            State.lastPos.longitude,
          ]);
          origin = `${pt.x}px ${pt.y}px`;
        }
        pane.style.transformOrigin = origin;
        pane.style.transform = `rotate(${-deg}deg)`;
        // keep popups upright
        const fixUpright = (els) => {
          els.forEach((el) => {
            const base = (el.style.transform || "").replace(/rotate\\([^)]*\\)/g, "");
            el.style.transformOrigin = "bottom center";
            el.style.transform = base + ` rotate(${deg}deg)`;
          });
        };
        const popups = map.getPanes().popupPane?.querySelectorAll(".leaflet-popup");
        const tooltips = map.getPanes().tooltipPane?.querySelectorAll(".leaflet-tooltip");
        if (popups) fixUpright(popups);
        if (tooltips) fixUpright(tooltips);
      }

      function refreshRay() {
        if (!State.lastPos || State.heading == null) {
          if (rayLine) rayLine.setLatLngs([]);
          return;
        }
        const from = {
          lat: State.lastPos.latitude,
          lng: State.lastPos.longitude,
        };
        if (!originDot) {
          originDot = L.circleMarker([from.lat, from.lng], {
            radius: 3,
            color: "#2aff2a",
            weight: 2,
            fillColor: "#2aff2a",
            fillOpacity: 1,
            interactive: false,
          }).addTo(map);
        } else {
          originDot.setLatLng([from.lat, from.lng]);
        }
        const length = Math.max(map.getSize().hypot() * map.distance(map.getCenter(), map.getCenter()) * 1.3, 2000);
        const destPt = L.latLng(
          from.lat + Math.cos(toRad(State.heading)) * (length / 111000),
          from.lng + Math.sin(toRad(State.heading)) * (length / 111000)
        );

        if (!rayLine) {
          rayLine = L.polyline([], { color: "#2aff2a", weight: 3, opacity: 1, interactive: false }).addTo(map);
        }
        rayLine.setLatLngs([from, destPt]);

        // color change if within active threshold
        const cand = getAlignmentCandidates();
        let hit = false;
        if (cand.length > 0) {
          for (const c of cand) {
            const brg = bearing(from, c.ll);
            const err = Math.abs(deltaAng(State.heading, brg));
            if (err <= Config.RAY_ACTIVE_THRESH) {
              hit = true;
              break;
            }
          }
        }
        rayLine.setStyle({ color: hit ? "#ff4444" : "#2aff2a", weight: hit ? 4 : 3 });
        if (hit) rayLine.getElement()?.classList.add("guide-hit");
        else rayLine.getElement()?.classList.remove("guide-hit");
      }

      function getAlignmentCandidates() {
        const arr = [];
        Waypoints.list.forEach((w) => arr.push({ name: w.name, ll: { lat: w.lat, lng: w.lng } }));
        if (Pins.pinMarker) {
          const ll = Pins.pinMarker.getLatLng();
          arr.push({ name: Pins.currentName, ll: { lat: ll.lat, lng: ll.lng } });
        }
        return arr;
      }

      function refreshNavLine() {
        if (!State.dest || !State.lastPos) {
          if (navLine) navLine.setLatLngs([]);
          return;
        }
        const from = { lat: State.lastPos.latitude, lng: State.lastPos.longitude };
        const to = { lat: State.dest.lat, lng: State.dest.lng };
        if (!navLine) {
          navLine = L.polyline([], {
            color: varAccent(),
            weight: 3,
            opacity: 0.9,
            interactive: false,
            dashArray: "6 6",
          }).addTo(map);
        }
        navLine.setLatLngs([from, to]);
        const b = bearing(from, to),
          d = haversine(from, to),
          err = State.heading == null ? null : deltaAng(State.heading, b);
        if (State.heading != null) {
          if (Math.abs(err) < 0.5) {
            navLine.setStyle({ color: "#ff4444", weight: 4 });
            navLine.getElement()?.classList.add("guide-hit");
          } else {
            navLine.setStyle({ color: varAccent(), weight: 3 });
            navLine.getElement()?.classList.remove("guide-hit");
          }
        }
      }

      function varAccent() {
        return getComputedStyle(document.documentElement).getPropertyValue("--accent") || "#3bb67c";
      }

      function updateHUD() {
        const lat = State.lastPos ? State.lastPos.latitude.toFixed(6) : "‚Äî";
        const lng = State.lastPos ? State.lastPos.longitude.toFixed(6) : "‚Äî";
        const acc = State.lastPos && State.lastPos.accuracy != null ? Math.round(State.lastPos.accuracy) : "‚Äî";
        const hd = State.heading != null ? State.heading.toFixed(2) : "‚Äî";
        const mb = norm360(-State.bearing).toFixed(2);
        const align = State.aligned?.name || State.flash.name || "none";

        let navHtml = "";
        if (State.dest && State.lastPos) {
          const from = { lat: State.lastPos.latitude, lng: State.lastPos.longitude };
          const to = { lat: State.dest.lat, lng: State.dest.lng };
          const b = bearing(from, to);
          const d = haversine(from, to);
          const err = State.heading == null ? "‚Äî" : deltaAng(State.heading, b).toFixed(2);
          navHtml = `
            <div class="metric"><span>To</span><b class="value">${State.dest.name}</b></div>
            <div class="metric"><span>Dist</span><b class="value">${distStr(d)}</b></div>
            <div class="metric"><span>Brg</span><b class="value">${b.toFixed(2)}¬∞</b></div>
            <div class="metric"><span>Œî</span><b class="value">${err}¬∞</b></div>
          `;
        }

        $("readout").innerHTML = `<div class="metrics">
          <div class="metric"><span>Lat</span><b class="value">${lat}</b></div>
          <div class="metric"><span>Lng</span><b class="value">${lng}</b></div>
          <div class="metric"><span>Acc</span><b class="value">${acc} m</b></div>
          <div class="metric"><span>Head</span><b class="value">${hd}¬∞</b></div>
          <div class="metric"><span>Map</span><b class="value">${mb}¬∞</b></div>
          <div class="metric"><span>Alignment</span><b class="value">${align}</b></div>
          ${navHtml}
        </div>`;
      }

      function checkAlignment() {
        const now = performance.now();
        if (!State.lastPos || State.heading == null) {
          State.pending = null;
          State.aligned = null;
          State.flash = { name: null, until: 0, target: null };
          return;
        }
        const from = { lat: State.lastPos.latitude, lng: State.lastPos.longitude };
        const head = State.heading;

        const cand = getAlignmentCandidates();
        if (cand.length === 0) {
          State.aligned = null;
          State.pending = null;
          return;
        }

        // find best instantaneous
        let best = null;
        let bestErr = Infinity;
        let bestDist = Infinity;
        for (const c of cand) {
          const brg = bearing(from, c.ll);
          const err = Math.abs(deltaAng(head, brg));
          const d = haversine(from, c.ll);
          if (err < bestErr || (err === bestErr && d < bestDist)) {
            best = { ...c, brg };
            bestErr = err;
            bestDist = d;
          }
        }

        // ray target priority
        const target = State.aligned || State.flash.target || best;
        const rayErr = target ? Math.abs(deltaAng(head, bearing(from, target.ll))) : Infinity;

        refreshRay();
        if (rayErr <= Config.RAY_ACTIVE_THRESH) {
          // highlight
        }

        // lock logic
        if (State.aligned) {
          const err = Math.abs(deltaAng(head, bearing(from, State.aligned.ll)));
          if (err <= Config.ALIGN.EXIT) {
            showAlignBanner(State.aligned.name);
            return;
          }
          State.aligned = null;
        }

        if (bestErr <= Config.ALIGN.ENTER) {
          if (State.pending && State.pending.name === best.name) {
            if (now - State.pending.since >= Config.ALIGN.DWELL_BASE - 0.6 * State.omega) {
              State.aligned = { name: best.name, ll: best.ll };
              State.pending = null;
              State.flash = { name: null, until: 0, target: null };
              showAlignBanner(best.name);
              vibrateHaptic();
              return;
            }
          } else {
            State.pending = { name: best.name, since: now };
          }
        } else {
          State.pending = null;
        }

        // flash scanning
        const step = Math.abs(deltaAng(State.prevHead || head, head));
        if (step <= 35) {
          for (const c of cand) {
            const brg = bearing(from, c.ll);
            if (deltaAng(State.prevHead || head, brg) * deltaAng(head, brg) < 0) {
              const err = Math.abs(deltaAng(head, brg));
              if (err < (State.flash.name === c.name ? 0.5 : Config.SCAN.FLASH)) {
                const last = State.flashCooldown?.[c.name] || 0;
                if (now - last > Config.SCAN.COOLDOWN) {
                  State.flash = { name: c.name, until: now + Config.SCAN.FLASH, target: c };
                  State.flashCooldown = State.flashCooldown || {};
                  State.flashCooldown[c.name] = now;
                  showAlignBanner(c.name);
                  vibrateHaptic();
                }
              }
            }
          }
        }
        if (State.flash.name && now > State.flash.until) {
          State.flash = { name: null, until: 0, target: null };
          hideAlignBanner();
        }

        State.prevHead = head;
      }

      function showAlignBanner(name) {
        const b = $("alignBanner");
        $("alignName").textContent = name || "‚Äî";
        b.classList.add("show");
      }
      function hideAlignBanner() {
        const b = $("alignBanner");
        $("alignName").textContent = "‚Äî";
        b.classList.remove("show");
      }

      function vibrateHaptic() {
        if ("vibrate" in navigator) navigator.vibrate(10);
      }

      function headingFromEvent(e) {
        const now = performance.now();
        const hasWCH = typeof e.webkitCompassHeading === "number";
        const isAbs = e.absolute === true || hasWCH;
        if (isAbs) {
          State.lastAbsTs = now;
          const magRaw = hasWCH ? e.webkitCompassHeading : e.alpha;
          setHeadingRaw(magRaw);
        } else {
          if (now - State.lastAbsTs < 120) return;
          if (typeof e.alpha === "number") {
            setHeadingRaw(e.alpha);
          }
        }
      }

      function setHeadingRaw(magRaw) {
        const mag = norm360(magRaw);
        const adj = norm360(mag + State.decl);
        const t = performance.now();
        if (
          State.heading == null ||
          Math.abs(deltaAng(State.heading, adj)) > 0.02
        ) {
          if (State.lastHeadTs != null && State.prevHead != null) {
            const dt = (t - State.lastHeadTs) / 1000;
            if (dt > 0)
              State.omega = Math.min(720, Math.abs(deltaAng(State.prevHead, adj)) / dt);
          }
          State.prevHead = adj;
          State.lastHeadTs = t;
          State.heading = adj;
          if (State.rotate && State.bearing == null) State.bearing = adj;
        } else {
          State.mag = mag;
        }
      }

      async function enableCompass() {
        if (State.rotate) return true;
        try {
          if (
            location.protocol !== "https:" &&
            location.hostname !== "localhost"
          ) {
            alert("Compass requires HTTPS.");
            return false;
          }
          if (
            typeof DeviceOrientationEvent !== "undefined" &&
            typeof DeviceOrientationEvent.requestPermission === "function"
          ) {
            const perm = await DeviceOrientationEvent.requestPermission();
            if (perm !== "granted") {
              alert("Compass permission denied.");
              return false;
            }
          }
          window.addEventListener("deviceorientationabsolute", headingFromEvent, true);
          window.addEventListener("deviceorientation", headingFromEvent, true);
          return true;
        } catch (ex) {
          alert("Compass access failed.");
          return false;
        }
      }

      function startGPS() {
        if (!("geolocation" in navigator)) {
          alert("Geolocation not supported.");
          return;
        }
        if (State.watchId != null) return;

        State.watchId = navigator.geolocation.watchPosition(
          (pos) => {
            State.lastPos = pos.coords;
            accCircle.setLatLng([pos.coords.latitude, pos.coords.longitude]);
            accCircle.setRadius(Math.max(pos.coords.accuracy || 0, 0));
            if (State.follow) {
              map.setView([pos.coords.latitude, pos.coords.longitude], Math.max(map.getZoom(), 16));
            }
            if (typeof pos.coords.heading === "number") {
              setHeadingRaw(pos.coords.heading);
            }
          },
          (err) => {
            alert("Unable to get location: " + err.message);
          },
          { enableHighAccuracy: true, maximumAge: 2000, timeout: 15000 }
        );
      }

      function loop() {
        const tgt = State.rotate ? (State.heading ?? 0) : 0;
        const err = Math.abs(deltaAng(State.bearing, tgt));
        const a = 0.12 + 0.38 * Math.min(1, (State.omega || 0) / 240);
        State.bearing = err < 0.08 ? State.bearing : norm360(State.bearing + a * deltaAng(State.bearing, tgt));
        applyMapRotation(State.bearing);

        refreshRay();
        if (State.dest) refreshNavLine();
        checkAlignment();
        updateHUD();

        requestAnimationFrame(loop);
      }

      function loadPersistedState() {
        try {
          const st = JSON.parse(localStorage.getItem("mapapp.state.v2") || "{}");
          if (typeof st.decl === "number") State.decl = st.decl;
          if (typeof st.rotate === "boolean") State.rotate = st.rotate;
          if (typeof st.follow === "boolean") State.follow = st.follow;
        } catch {}
      }

      // Kick off
      initMap();
      loadPersistedState();
      Waypoints.load();
      Waypoints.renderListUI();
      Waypoints.syncMarkers();
      bindUIEvents();
      bindMapInteractions();
      loop();
    });
  </script>
</body>
</html>
