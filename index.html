<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Spherical Compass</title>
<style>
  :root{--bg:#0b0f12;--ink:#e8f1f0;--muted:#a9c6c0;--brand:#22d7b7;--line:rgba(255,255,255,.15)}
  html,body{height:100%;margin:0;background:radial-gradient(120% 140% at 50% 20%,#131a20 0%,#0b0f12 60%,#06080a 100%);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  #app{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto}
  header,footer{display:flex;align-items:center;gap:.75rem;padding:.6rem .9rem;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,0));backdrop-filter:blur(6px)}
  header{justify-content:space-between;border-bottom:1px solid var(--line)}
  footer{justify-content:space-between;border-top:1px solid var(--line)}
  .btn{appearance:none;border:1px solid var(--line);background:rgba(255,255,255,.06);color:var(--ink);padding:.55rem .8rem;border-radius:12px;font-weight:600;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .metric{font-variant-numeric:tabular-nums}
  #canvas{display:block;width:100%;height:100%}
  .hud{position:absolute;inset:auto 0 60px 0;display:flex;justify-content:center;pointer-events:none}
  .card{pointer-events:auto;display:inline-flex;align-items:center;gap:.75rem;padding:.7rem 1rem;background:rgba(5,8,12,.6);border:1px solid var(--line);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .pill{padding:.35rem .6rem;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid var(--line)}
  .legend{position:absolute;inset:12px auto auto 12px;display:flex;flex-direction:column;gap:.4rem}
  .legend span{display:inline-block;padding:.25rem .5rem;border-radius:9px;background:rgba(255,255,255,.06);border:1px solid var(--line);font-size:.85rem}
  .notice{font-size:.9rem;color:var(--muted)}
</style>
</head>
<body>
<div id="app">
  <header>
    <div style="display:flex;align-items:center;gap:.6rem">
      <strong>ðŸ§­ Spherical Compass</strong>
      <span class="notice">Trueâ€‘north needle inside a 3D sphere. Works with device orientation or mouse.</span>
    </div>
    <div style="display:flex;gap:.5rem">
      <button id="perm" class="btn" title="iOS 13+ requires a tap to grant sensor access">Enable Motion Sensors</button>
      <button id="recenter" class="btn">Reâ€‘center</button>
    </div>
  </header>
  <main style="position:relative">
    <canvas id="canvas"></canvas>
    <div class="legend">
      <span>Drag: orbit</span>
      <span>Wheel: zoom</span>
    </div>
    <div class="hud">
      <div class="card">
        <div class="pill"><span>Heading</span></div>
        <div class="metric"><span id="heading">â€”</span>Â°</div>
        <div class="pill"><span id="mode">Idle</span></div>
      </div>
    </div>
  </main>
  <footer>
    <div class="notice">If your device supports <code>AbsoluteOrientationSensor</code> or <code>DeviceOrientation</code>, the needle points to true north. On desktops, use mouse to look around.</div>
    <div class="notice">Made with Three.js</div>
  </footer>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/examples/js/controls/OrbitControls.js" crossorigin="anonymous"></script>
<script>
(function(){
  const canvas = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 1000);
  camera.position.set(0, 0, 5);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.enablePan = false;

  // Lighting
  const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(3,4,5); scene.add(dir);

  // Spherical grid (lat/long wireframe)
  const sphere = new THREE.Mesh(
    new THREE.SphereGeometry(2.6, 48, 32),
    new THREE.MeshBasicMaterial({color:0x6ccac0, wireframe:true, transparent:true, opacity:0.18})
  );
  scene.add(sphere);

  // Horizon ring
  const ring = new THREE.Mesh(
    new THREE.TorusGeometry(2.0, 0.01, 12, 240),
    new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.35})
  );
  ring.rotation.x = Math.PI/2; scene.add(ring);

  // Cardinal labels (billboard sprites)
  const makeLabel = (text, color)=>{
    const s=128; const cnv=document.createElement('canvas'); cnv.width=cnv.height=s;
    const ctx=cnv.getContext('2d');
    ctx.fillStyle='rgba(0,0,0,0)'; ctx.fillRect(0,0,s,s);
    ctx.fillStyle=color; ctx.font='700 72px system-ui,Segoe UI,Roboto,Inter,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.shadowColor='rgba(0,0,0,.6)'; ctx.shadowBlur=12; ctx.fillText(text,s/2,s/2);
    const tex=new THREE.CanvasTexture(cnv); tex.anisotropy=8; tex.needsUpdate=true;
    const mat=new THREE.SpriteMaterial({map:tex, depthTest:false});
    const spr=new THREE.Sprite(mat); spr.scale.set(0.7,0.7,0.7);
    return spr;
  };
  const N=makeLabel('N','#f15b5b'), E=makeLabel('E','#e8f1f0'), S=makeLabel('S','#e8f1f0'), W=makeLabel('W','#e8f1f0');
  N.position.set(0,0,-2.1); S.position.set(0,0,2.1); E.position.set(2.1,0,0); W.position.set(-2.1,0,0);
  scene.add(N,E,S,W);

  // Needle (points to world +Z when heading=0)
  const needleGroup = new THREE.Group();
  const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,1.8,16), new THREE.MeshStandardMaterial({color:0xe8f1f0, metalness:.2, roughness:.3}));
  shaft.position.y = 0.9; needleGroup.add(shaft);
  const tip = new THREE.Mesh(new THREE.ConeGeometry(0.09,0.35,24), new THREE.MeshStandardMaterial({color:0xff4d4d, metalness:.3, roughness:.25}));
  tip.position.y = 1.85; needleGroup.add(tip);
  const base = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.12,24), new THREE.MeshStandardMaterial({color:0x22d7b7, metalness:.4, roughness:.35}));
  base.position.y = 0; needleGroup.add(base);
  // Rotate around world Y to follow heading
  needleGroup.position.set(0,-1.4,0);
  scene.add(needleGroup);

  // Ground plane (subtle)
  const ground = new THREE.Mesh(new THREE.CircleGeometry(2.15, 120), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:.06}));
  ground.rotation.x = -Math.PI/2; ground.position.y = -1.4; scene.add(ground);

  // Resize
  function resize(){
    const {clientWidth:w, clientHeight:h} = renderer.domElement.parentElement;
    renderer.setSize(w,h,false); camera.aspect = w/h; camera.updateProjectionMatrix();
  }
  addEventListener('resize', resize, {passive:true}); resize();

  // Heading & sensor handling
  const headingEl = document.getElementById('heading');
  const modeEl = document.getElementById('mode');
  const recenterBtn = document.getElementById('recenter');
  const permBtn = document.getElementById('perm');
  let useSensor = false; let heading = 0; // degrees, 0 = North
  let yawOffset = 0; // for recenter when using mouse look

  recenterBtn.addEventListener('click', ()=>{ yawOffset = heading; });

  // iOS permission helper
  async function requestIOSPermission(){
    try{
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
        await DeviceMotionEvent.requestPermission();
      }
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
        await DeviceOrientationEvent.requestPermission();
      }
      modeEl.textContent = 'Sensors enabled';
      startSensors();
    }catch(e){ modeEl.textContent = 'Permission denied'; console.warn(e); }
  }
  permBtn.addEventListener('click', requestIOSPermission);

  function startSensors(){
    // Prefer AbsoluteOrientationSensor if supported
    try{
      // Some browsers block this behind flags; guard with existence checks
      const AOS = window.AbsoluteOrientationSensor || window.RelativeOrientationSensor;
      if (AOS){
        const sensor = new AOS({frequency:60, referenceFrame:'device'});
        sensor.addEventListener('reading', ()=>{
          // sensor.quaternion is device->world, world axes: x-east, y-north, z-up
          const q = sensor.quaternion; // [x,y,z,w]
          // Convert quaternion to yaw (heading from north), in degrees
          const x=q[0], y=q[1], z=q[2], w=q[3];
          // Yaw from quaternion (assuming ENU):
          const siny_cosp = 2*(w*z + x*y);
          const cosy_cosp = 1 - 2*(y*y + z*z);
          let yaw = Math.atan2(siny_cosp, cosy_cosp); // radians, +Z as yaw
          // Convert to degrees heading where 0=north (+Y in ENU). Adjust by -90Â°.
          let hdg = ((THREE.MathUtils.radToDeg(yaw) - 90) % 360 + 360) % 360;
          heading = hdg;
          modeEl.textContent = 'AbsoluteOrientationSensor';
        });
        sensor.addEventListener('error', e=>{ console.warn(e.error||e); modeEl.textContent = 'Sensor error'; });
        sensor.start(); useSensor = true; return;
      }
    }catch(err){ console.warn('AOS error', err); }

    // Fallback: DeviceOrientationEvent
    if ('ondeviceorientationabsolute' in window){
      window.addEventListener('deviceorientationabsolute', handleOrientation, true);
      useSensor = true; modeEl.textContent = 'deviceorientationabsolute'; return;
    }
    if ('ondeviceorientation' in window){
      window.addEventListener('deviceorientation', handleOrientation, true);
      useSensor = true; modeEl.textContent = 'deviceorientation'; return;
    }

    modeEl.textContent = 'No sensors';
  }

  function handleOrientation(e){
    // iOS provides webkitCompassHeading (0=N)
    if (typeof e.webkitCompassHeading === 'number' && !isNaN(e.webkitCompassHeading)){
      heading = e.webkitCompassHeading;
    } else if (typeof e.alpha === 'number'){
      // alpha: 0..360Â° clockwise from device facing (varies by browser). Heuristic: 0=N by flipping.
      // Many browsers use 0Â° when device points north and increase clockwise: heading â‰ˆ 360 - alpha
      heading = (360 - e.alpha + 360) % 360;
    }
  }

  // Desktop: approximate heading from camera orbit when no sensors
  function computeDesktopHeading(){
    // project camera look vector onto XZ plane and compute azimuth where +Z = North
    const v = new THREE.Vector3(); camera.getWorldDirection(v); v.y = 0; v.normalize();
    let az = Math.atan2(v.x, v.z); // radians, 0 at +Z, +clockwise to +X
    let hdg = (THREE.MathUtils.radToDeg(az) + 360) % 360;
    return hdg;
  }

  // Start sensors automatically on nonâ€‘iOS (iOS needs a user gesture)
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints>1);
  if (!isIOS) startSensors();

  // Render loop
  function animate(){
    requestAnimationFrame(animate);
    if (!useSensor){ heading = computeDesktopHeading(); }

    // Apply heading to needle: rotate around Y so that 0Â° = facing +Z (North label)
    const needleYaw = THREE.MathUtils.degToRad(heading - yawOffset);
    needleGroup.rotation.y = needleYaw;

    headingEl.textContent = (Math.round(heading*10)/10).toFixed(1);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
})();
</script>
</body>
</html>
