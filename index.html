<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"/>
<meta name="theme-color" content="#0b0f12"/>
<title>Azimuth & Elevation Alignment Tool</title>
<style>
:root{
  --bg:#0b0f12; --ink:#e9f5f0; --muted:#a8cfc0; --accent:#20d7b7; --warn:#ffb020; --bad:#ff5a69; --good:#38e27d;
  --line:rgba(255,255,255,.12); --panel:#10171d; --chip:#121c23; --backdrop:rgba(3,6,8,.6);
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;overscroll-behavior:none}
button,input,select,textarea{font:inherit}
a{color:var(--accent);text-decoration:none}
.app{height:100svh;display:flex;flex-direction:column}
.safe{padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right)}

/* Top status */
.top{height:42px;display:flex;align-items:center;gap:.6rem;padding:.4rem .8rem;border-bottom:1px solid var(--line);background:linear-gradient(180deg,var(--bg),rgba(11,15,18,.92))}
.badge{background:var(--chip);border:1px solid var(--line);border-radius:10px;padding:.25rem .5rem;color:var(--muted);font-size:.85rem;white-space:nowrap}
.grow{margin-left:auto;display:flex;gap:.4rem;align-items:center}
.btn{background:#17242c;border:1px solid var(--line);color:var(--ink);padding:.5rem .8rem;border-radius:10px;cursor:pointer}
.btn.small{padding:.35rem .6rem;font-size:.9rem}
.btn.primary{background:var(--accent);color:#071012;border-color:transparent;font-weight:700}
.btn:disabled{opacity:.5;cursor:not-allowed}

/* Main stage */
.main{position:relative;flex:1;display:flex;align-items:center;justify-content:center;padding:.6rem}
.stage{position:relative;width:100%;height:100%;display:grid;place-items:center}
.compassWrap{position:relative;width:100%;max-width:clamp(260px,90vw,560px);aspect-ratio:1/1;display:grid;place-items:center}
.compass{
  width:100%;aspect-ratio:1/1;border-radius:50%;
  background:radial-gradient(120% 120% at 50% 0%, #1a232b 0%, #11171d 60%, #0b1015 100%);
  box-shadow:inset 0 0 0 2px rgba(255,255,255,.06), inset 0 20px 50px rgba(0,0,0,.55);
  position:relative;transform:perspective(900px) rotateX(18deg);border:1px solid var(--line);overflow:hidden /* IMPORTANT: clips map canvas */
}
.tick{position:absolute;left:50%;top:50%;transform-origin:0% 0%}
.tickLine{width:48%;height:1px;background:rgba(255,255,255,.25);transform-origin:left center}
.tickTxt{position:absolute;right:6%;top:-10px;font-size:.8rem;color:var(--muted)}
.arrow{position:absolute;left:50%;top:50%;width:0;height:0;transform-origin:50% calc(100% - 18px);filter:drop-shadow(0 2px 2px rgba(0,0,0,.6)); pointer-events:none}
.arrow svg{width:44%;height:auto;transform:translate(-50%,-72%)}

.centerReadout{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) rotateX(-18deg);text-align:center;user-select:none;pointer-events:none}
.big{font-size:clamp(20px,5.6vw,34px);font-weight:800}
.mid{color:var(--muted);font-size:clamp(12px,3.6vw,16px)}
.delta{font-weight:800}
.delta.good{color:var(--good)} .delta.warn{color:var(--warn)} .delta.bad{color:var(--bad)}
.targetChip{position:absolute;left:10%;top:12%;transform:rotateX(-18deg);background:var(--chip);border:1px solid var(--line);border-radius:999px;padding:.25rem .6rem;color:var(--muted);font-size:.85rem}

/* Embedded radar map in the compass */
#radarCanvas{position:absolute;inset:0;width:100%;height:100%}
.radarUI{position:absolute;inset:auto 6% 8% auto;display:grid;gap:8px;transform:rotateX(-18deg)}
.rbtn{min-width:40px;height:36px;border-radius:10px;border:1px solid var(--line);background:#14222a;color:var(--ink);font-weight:700}
.rbtn.toggled{outline:2px solid var(--accent)}
.zoomUI{position:absolute;right:6%;top:12%;display:grid;gap:6px;transform:rotateX(-18deg)}
.wayUI{position:absolute;left:6%;top:12%;transform:rotateX(-18deg)}
.pill{background:#0f1a20;border:1px solid var(--line);border-radius:999px;padding:.25rem .6rem;color:var(--muted);font-size:.85rem}

/* Elevation bar */
.elevBar{position:absolute;right:4%;top:8%;bottom:14%;width:12px;min-height:120px;background:#15222b;border:1px solid var(--line);border-radius:10px}
.mark{position:absolute;left:50%;width:18px;height:2px;background:rgba(255,255,255,.25);transform:translateX(-50%)}
.targetDot{position:absolute;left:50%;width:12px;height:12px;background:var(--accent);border-radius:50%;transform:translate(-50%,-50%);box-shadow:0 0 0 2px rgba(32,215,183,.25)}
.currTri{position:absolute;left:50%;transform:translate(-50%,-50%);width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:12px solid #fff}
.elevLegend{position:absolute;right:2%;bottom:8%;font-size:.85rem;color:var(--muted)}

/* Bottom actions */
.actions{height:64px;display:flex;align-items:center;justify-content:space-around;padding:.3rem .6rem;border-top:1px solid var(--line);background:linear-gradient(180deg,rgba(11,15,18,.92),var(--bg))}
.fab{min-width:64px;height:44px;border-radius:12px;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:.1rem;background:#14222a;border:1px solid var(--line);color:var(--ink)}
.fab span{font-size:11px;color:var(--muted)}

/* Floating menus */
.backdrop{position:fixed;inset:0;background:var(--backdrop);display:none}
.sheet{position:fixed;left:env(safe-area-inset-left);right:env(safe-area-inset-right);bottom:0;max-height:88svh;background:var(--panel);border-top-left-radius:16px;border-top-right-radius:16px;border:1px solid var(--line);transform:translateY(100%);transition:transform .2s ease-out;display:flex;flex-direction:column}
.sheet.open{transform:translateY(0)}
.backdrop.show{display:block}
.sheetHdr{display:flex;align-items:center;gap:.6rem;padding:.6rem .8rem;border-bottom:1px solid var(--line)}
.sheetHdr .title{font-weight:800}
.sheetBody{padding:.8rem;overflow:auto}
.row{display:flex;gap:.5rem;flex-wrap:wrap}
.field{display:flex;flex-direction:column;gap:.25rem;min-width:46%}
.field label{color:var(--muted);font-size:.9rem}
.field input,.field select,.field textarea{background:#0e171d;border:1px solid var(--line);border-radius:10px;padding:.5rem .6rem;color:var(--ink)}
hr.sep{border:none;border-top:1px solid var(--line);margin:1rem 0}
.tabbar{display:flex;border:1px solid var(--line);border-radius:10px;overflow:hidden}
.tabbar button{flex:1;padding:.45rem .6rem;background:#0f1820;border:none;color:var(--muted)}
.tabbar button.active{background:#17242c;color:var(--ink);font-weight:700}
.closeX{margin-left:auto}
.largeText .big{font-size:clamp(26px,7vw,40px)}
.largeText .mid{font-size:clamp(14px,4.5vw,18px)}
</style>
</head>
<body>
<div class="app">
  <!-- Top status -->
  <div class="top safe">
    <div class="badge" id="gpsBadge">GPS ‚Äî</div>
    <div class="badge" id="magBadge">Mag ‚Äî</div>
    <div class="badge" id="hzBadge">Hz ‚Äî</div>
    <div class="badge" id="statusBadge">Ready</div>
    <div class="grow">
      <button class="btn small" id="startBtn">Start</button>
    </div>
  </div>

  <!-- Main stage -->
  <div class="main safe">
    <div class="stage">
      <div class="compassWrap">
        <canvas id="radarCanvas"></canvas> <!-- NEW: embedded map -->
        <div class="compass" id="compass"></div>

        <!-- Mini toolbar inside compass -->
        <div class="wayUI"><button class="rbtn" id="btnWaypoints">üìç</button> <span class="pill" id="radarDistLbl">‚Äî</span></div>
        <div class="zoomUI">
          <button class="rbtn" id="zoomIn">Ôºã</button>
          <button class="rbtn" id="zoomOut">Ôºç</button>
        </div>
        <div class="radarUI">
          <button class="rbtn" id="btnFollow" title="Follow (you centered)">Follow</button>
          <button class="rbtn" id="btnRotate" title="Rotate with heading">Rotate</button>
        </div>

        <div class="targetChip" id="targetChip">Target: Az ‚Äî¬∞, El ‚Äî¬∞</div>
        <div class="centerReadout">
          <div class="big"><span id="headingNum">‚Äî</span>¬∞ <span id="headingCard">---</span></div>
          <div class="mid">ŒîAz: <span id="deltaAz" class="delta">‚Äî</span> ¬∑ ŒîEl: <span id="deltaEl" class="delta">‚Äî</span></div>
        </div>

        <!-- Elevation bar -->
        <div class="elevBar" id="elevBar">
          <div class="mark" style="top:10%"></div><div class="mark" style="top:30%"></div>
          <div class="mark" style="top:50%"></div><div class="mark" style="top:70%"></div><div class="mark" style="top:90%"></div>
          <div class="targetDot" id="elTargetDot" style="top:50%"></div>
          <div class="currTri" id="elCurrTri" style="top:50%"></div>
        </div>
        <div class="elevLegend">0‚Äì60¬∞</div>
      </div>
    </div>
  </div>

  <!-- Actions -->
  <div class="actions safe">
    <button class="fab" id="fabTarget">üéØ<span>Target</span></button>
    <button class="fab" id="fabSensors">üß≠<span>Sensors</span></button>
    <button class="fab" id="fabOptions">‚öôÔ∏è<span>Options</span></button>
    <button class="fab" id="fabPresets">‚≠ê<span>Presets</span></button>
  </div>
</div>

<!-- Backdrop -->
<div class="backdrop" id="backdrop"></div>

<!-- Target Sheet -->
<div class="sheet" id="sheetTarget" role="dialog" aria-modal="true">
  <div class="sheetHdr"><div class="title">Target</div><button class="btn small closeX" data-close="sheetTarget">Close</button></div>
  <div class="sheetBody">
    <div class="tabbar" id="targetTabs">
      <button data-tab="azEl" class="active">Az & El</button>
      <button data-tab="coords">Coords</button>
    </div>

    <div id="tabAzEl" style="margin-top:.8rem">
      <div class="row">
        <div class="field"><label>Azimuth (¬∞)</label><input id="azInput" type="number" step="0.1" value="0"></div>
        <div class="field"><label>Elevation (¬∞)</label><input id="elInput" type="number" step="0.1" value="0"></div>
      </div>
      <div class="row" style="margin-top:.5rem">
        <button class="btn" id="btnSetTargetAzEl">Set target</button>
        <button class="btn" id="btnPaste">Paste</button>
      </div>
      <div class="field" style="margin-top:.5rem">
        <label>Paste vendor line (optional)</label>
        <textarea id="pasteBox" rows="3" placeholder="latA,lonA,AGL_A,groundA; latB,lonB,AGL_B,groundB; heading¬∞, elevation¬∞"></textarea>
        <div class="row" style="margin-top:.4rem">
          <button class="btn" id="btnParse">Parse</button>
        </div>
      </div>
    </div>

    <div id="tabCoords" style="display:none;margin-top:.8rem">
      <div class="row">
        <div class="field"><label>A (You) lat</label><input id="alat" type="number" step="0.000001"></div>
        <div class="field"><label>A lon</label><input id="alon" type="number" step="0.000001"></div>
      </div>
      <div class="row">
        <div class="field"><label>A ground elev (m)</label><input id="aGround" type="number" step="0.1"></div>
        <div class="field"><label>A mast AGL (m)</label><input id="aAGL" type="number" step="0.1" value="3"></div>
      </div>
      <hr class="sep"/>
      <div class="row">
        <div class="field"><label>B (Target) lat</label><input id="blat" type="number" step="0.000001"></div>
        <div class="field"><label>B lon</label><input id="blon" type="number" step="0.000001"></div>
      </div>
      <div class="row">
        <div class="field"><label>B ground elev (m)</label><input id="bGround" type="number" step="0.1"></div>
        <div class="field"><label>B mast AGL (m)</label><input id="bAGL" type="number" step="0.1" value="3"></div>
      </div>
      <div class="row" style="margin-top:.6rem">
        <button class="btn" id="btnCompute">Compute</button>
        <span class="pill">Az: <span id="computedAz">‚Äî</span>¬∞</span>
        <span class="pill">El: <span id="computedEl">‚Äî</span>¬∞</span>
        <span class="pill">F1@mid: <span id="f1Lbl">‚Äî</span></span>
        <span class="pill">Drop: <span id="dropLbl">‚Äî</span> m</span>
      </div>
    </div>
  </div>
</div>

<!-- Sensors Sheet -->
<div class="sheet" id="sheetSensors">
  <div class="sheetHdr"><div class="title">Sensors</div><button class="btn small closeX" data-close="sheetSensors">Close</button></div>
  <div class="sheetBody">
    <div class="row">
      <div class="field"><label>Mode</label><select id="modeSelect"><option value="true">True</option><option value="mag">Magnetic</option></select></div>
      <div class="field"><label>Declination (¬∞)</label><input id="declInput" type="number" step="0.1" value="0"></div>
    </div>
    <div class="row">
      <div class="field"><label>Az offset (¬∞)</label><input id="azOffset" type="number" step="0.1" value="0"></div>
      <div class="field"><label>El offset (¬∞)</label><input id="elOffset" type="number" step="0.1" value="0"></div>
    </div>
    <div class="row">
      <div class="field"><label>Az smoothing Œ±</label><input id="alphaAz" type="number" step="0.05" min="0" max="1" value="0.2"></div>
      <div class="field"><label>El smoothing Œ±</label><input id="alphaEl" type="number" step="0.05" min="0" max="1" value="0.2"></div>
    </div>
    <hr class="sep"/>
    <div class="row">
      <span class="pill">Orientation: <span id="oriMode">‚Äî</span></span>
      <span class="pill">Field: <span id="magLbl">‚Äî</span></span>
      <span class="pill">Sample: <span id="hzLbl">‚Äî</span> Hz</span>
    </div>
  </div>
</div>

<!-- Options Sheet -->
<div class="sheet" id="sheetOptions">
  <div class="sheetHdr"><div class="title">Options</div><button class="btn small closeX" data-close="sheetOptions">Close</button></div>
  <div class="sheetBody">
    <div class="row">
      <div class="field"><label>Az tolerance (¬∞)</label><input id="tolAz" type="number" step="0.1" value="2"></div>
      <div class="field"><label>El tolerance (¬∞)</label><input id="tolEl" type="number" step="0.1" value="1"></div>
    </div>
    <div class="row">
      <div class="field"><label>Units</label><select id="unitSelect"><option value="metric">Metric (m, km)</option><option value="imperial">Imperial (ft, mi)</option></select></div>
      <div class="field"><label>Frequency (GHz)</label><input id="freqInput" type="number" step="0.1" value="5.8"></div>
    </div>
    <div class="row">
      <div class="field"><label>K factor</label><input id="kInput" type="number" step="0.01" value="1.333"></div>
      <div class="field"><label>Fresnel warn level</label><select id="fresnelWarn"><option value="0.6">60%</option><option value="0.8">80%</option></select></div>
    </div>
    <div class="row">
      <label class="pill"><input id="largeText" type="checkbox" style="accent-color:var(--accent)"> Large Text</label>
      <label class="pill"><input id="haptics" type="checkbox" checked style="accent-color:var(--accent)"> Haptics</label>
    </div>
  </div>
</div>

<!-- Presets Sheet -->
<div class="sheet" id="sheetPresets">
  <div class="sheetHdr"><div class="title">Presets</div><button class="btn small closeX" data-close="sheetPresets">Close</button></div>
  <div class="sheetBody">
    <div class="row">
      <select id="presetSelect" style="flex:1"><option value="">Select preset‚Ä¶</option></select>
      <button class="btn" id="btnLoadPreset">Load</button>
    </div>
    <div class="row" style="margin-top:.6rem">
      <button class="btn" id="btnSavePreset">Save current‚Ä¶</button>
      <button class="btn" id="btnExport">Export JSON</button>
      <button class="btn" id="btnImport">Import JSON</button>
    </div>
    <textarea id="jsonBox" rows="6" placeholder="Preset JSON will appear here for export/import" style="margin-top:.6rem;width:100%"></textarea>
  </div>
</div>

<script>
/* ===== Utilities ===== */
const toRad = d => d*Math.PI/180, toDeg = r => r*180/Math.PI;
const clamp = (v,min,max)=>Math.min(max,Math.max(min,v));
const wrap360 = d => (d%360+360)%360;
const cardinals = deg => { const dirs=["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"]; return dirs[Math.round(wrap360(deg)/22.5)%16]; };
const shortestAngle = (t,h)=>(((t - h + 540) % 360) - 180);
const haversine = (a,b) => { const R=6371000; const œÜ1=toRad(a.lat), œÜ2=toRad(b.lat), dœÜ=toRad(b.lat-a.lat), dŒª=toRad(b.lon-a.lon); const s=Math.sin(dœÜ/2)**2 + Math.cos(œÜ1)*Math.cos(œÜ2)*Math.sin(dŒª/2)**2; return 2*R*Math.asin(Math.sqrt(s)); };
const bearing = (a,b) => { const œÜ1=toRad(a.lat), œÜ2=toRad(b.lat), ŒîŒª=toRad(b.lon-a.lon); const y=Math.sin(ŒîŒª)*Math.cos(œÜ2); const x=Math.cos(œÜ1)*Math.sin(œÜ2)-Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(ŒîŒª); return wrap360(toDeg(Math.atan2(y,x))); };
const earthDrop = (D,K=1.333)=> (D*D)/(2*(K*6371000));
const aimElevation = (A,B,D,K=1.333)=>{ const hA=(A.ground??0)+(A.agl??0), hB=(B.ground??0)+(B.agl??0); const drop=earthDrop(D,K); return {el: toDeg(Math.atan2((hB-hA)-drop, D)), drop}; };
const fresnelF1mid = (D_km,f_GHz)=> 17.32*Math.sqrt((D_km/2)*(D_km/2)/(f_GHz*D_km));
const mToFt = m=>m*3.28084, kmToMi = km=>km*0.621371;
function fmtDist(km, units){ return (units==="metric")? `${km.toFixed(2)} km`:`${kmToMi(km).toFixed(2)} mi`; }
function fmtF1(m, units){ return (units==="metric")? `${m.toFixed(2)} m`:`${mToFt(m).toFixed(1)} ft`; }

/* ===== State ===== */
const state = {
  running:false, units:"metric",
  mode:"true", decl:0,
  azOffset:0, elOffset:0,
  alphaAz:0.2, alphaEl:0.2,
  K:1.333, freq:5.8, fresnelWarn:0.6,
  tolAz:2, tolEl:1, haptics:true, largeText:false,
  heading:null, pitch:null, field:null, oriMode:"auto",
  ema:{heading:null,pitch:null},
  you:{lat:null,lon:null,acc:null}, youAge:"‚Äî",
  target:{has:false, az:null, el:null, distKm:null, a:null, b:null},
  lastTick:0, hz:0, smp:0, t0:performance.now(),
  screenOrient:()=> (screen.orientation && screen.orientation.angle)|| window.orientation || 0
};

/* ===== DOM refs ===== */
const $=s=>document.querySelector(s);
const compass=$("#compass");
const headingNum=$("#headingNum"), headingCard=$("#headingCard");
const deltaAz=$("#deltaAz"), deltaEl=$("#deltaEl"), targetChip=$("#targetChip");
const elTargetDot=$("#elTargetDot"), elCurrTri=$("#elCurrTri");
const gpsBadge=$("#gpsBadge"), magBadge=$("#magBadge"), hzBadge=$("#hzBadge"), statusBadge=$("#statusBadge");
const radar=document.getElementById("radarCanvas");
const rctx=radar.getContext("2d");

/* ===== Build ticks & arrow ===== */
function buildTicks(){
  const arrow=document.createElement("div"); arrow.className="arrow"; arrow.id="arrow";
  arrow.innerHTML = `<svg viewBox="0 0 200 260" xmlns="http://www.w3.org/2000/svg">
    <defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#ffffff" stop-opacity="0.92"/><stop offset="1" stop-color="#bcd2d9" stop-opacity="0.92"/></linearGradient></defs>
    <path d="M100 15 L140 200 L100 175 L60 200 Z" fill="url(#g)" stroke="rgba(0,0,0,.25)" stroke-width="2"/>
    <circle cx="100" cy="205" r="18" fill="#0e171d" stroke="rgba(255,255,255,.2)" stroke-width="2"/>
  </svg>`;
  compass.appendChild(arrow);
  for(let d=0; d<360; d+=5){
    const t=document.createElement("div"); t.className="tick";
    t.style.transform=`rotate(${d}deg) translate(-50%,-50%)`;
    const line=document.createElement("div"); line.className="tickLine";
    line.style.opacity=(d%10===0)?1:0.5; line.style.height=(d%30===0)?"2px":"1px";
    t.appendChild(line);
    if(d%30===0){
      const txt=document.createElement("div"); txt.className="tickTxt";
      txt.textContent=(d===0)?"N":(d===90?"E":(d===180?"S":(d===270?"W":d)));
      t.appendChild(txt);
    }
    compass.appendChild(t);
  }
}
buildTicks();
const arrowEl=$("#arrow");

/* ===== Rendering (numbers, deltas) ===== */
function colorForDelta(x,t){ const ax=Math.abs(x); return (ax<=t)?'good':(ax<=t*2.5)?'warn':'bad'; }
function moveElMarkers(targetEl, currEl){ const mapY = v => (10 + (60 - clamp(v,0,60))*(80/60)); elTargetDot.style.top = mapY(targetEl)+"%"; elCurrTri.style.top = mapY(currEl)+"%"; }
function render(){
  if(state.heading!=null){ headingNum.textContent=state.heading.toFixed(1); headingCard.textContent=cardinals(state.heading); }
  arrowEl.style.transform = `translate(-50%,-50%) rotate(${state.heading||0}deg)`;
  const tAz=state.tolAz, tEl=state.tolEl;
  if(state.target.has && state.heading!=null){
    const dAz = shortestAngle(state.target.az, state.heading);
    deltaAz.textContent = (dAz>0?"+":"")+dAz.toFixed(1)+"¬∞";
    deltaAz.className = "delta " + colorForDelta(dAz,tAz);
    const currPitch = (state.pitch??0) + state.elOffset;
    if(state.target.el!=null){
      const dEl = (state.target.el - currPitch);
      deltaEl.textContent = (dEl>0?"+":"")+dEl.toFixed(1)+"¬∞";
      deltaEl.className = "delta " + colorForDelta(dEl,tEl);
      moveElMarkers(state.target.el, currPitch);
      if(Math.abs(dAz)<=tAz && Math.abs(dEl)<=tEl && state.haptics && (Date.now()-state.lastTick>800)){
        if(navigator.vibrate) navigator.vibrate(30); state.lastTick=Date.now();
      }
    }
  }
  hzBadge.textContent = "Hz " + state.hz.toFixed(0);
  $("#hzLbl") && ($("#hzLbl").textContent = state.hz.toFixed(0));
  $("#oriMode") && ($("#oriMode").textContent = state.oriMode);
  $("#magLbl") && ($("#magLbl").textContent = state.field? "ok":"‚Äî");
}

/* ===== Sensors ===== */
async function startSensors(){
  try{
    if(navigator.geolocation){
      navigator.geolocation.watchPosition(pos=>{
        const {latitude,longitude,accuracy} = pos.coords;
        state.you={lat:latitude,lon:longitude,acc:accuracy};
      },err=>{ gpsBadge.textContent="GPS denied"; },{enableHighAccuracy:true, maximumAge:1000, timeout:15000});
    } else gpsBadge.textContent="GPS n/a";

    if (typeof DeviceOrientationEvent !== "undefined" &&
        typeof DeviceOrientationEvent.requestPermission === "function") {
      const res = await DeviceOrientationEvent.requestPermission();
      if (res !== "granted") throw new Error("Motion permission denied");
    }
    window.addEventListener("deviceorientation", onOrientation, true);
    state.running=true; statusBadge.textContent="Running";
  }catch(e){ statusBadge.textContent="Start failed: "+e.message; }
}
function onOrientation(e){
  let heading;
  if (typeof e.webkitCompassHeading === "number"){
    heading = e.webkitCompassHeading; state.oriMode="webkitCompassHeading";
  } else if (typeof e.alpha === "number"){
    let alpha=e.alpha, so=state.screenOrient();
    if (so===90) alpha+=90; else if (so===-90 || so===270) alpha-=90; else if (so===180) alpha+=180;
    heading = 360 - (alpha%360); state.oriMode="alpha-derived";
  }
  if (heading!=null){
    const decl=parseFloat($("#declInput").value)||0;
    const mode=$("#modeSelect").value;
    if(mode==="true") heading = wrap360(heading + decl);
    heading = wrap360(heading + (parseFloat($("#azOffset").value)||0));
    const a = parseFloat($("#alphaAz").value)||0.2;
    state.ema.heading = (state.ema.heading==null)? heading : (state.ema.heading*(1-a) + heading*a);
    state.heading = wrap360(state.ema.heading);
  }
  if (typeof e.beta === "number"){
    let pitch = clamp(e.beta,-90,90) + (parseFloat($("#elOffset").value)||0);
    const a = parseFloat($("#alphaEl").value)||0.2;
    state.ema.pitch = (state.ema.pitch==null)? pitch : (state.ema.pitch*(1-a) + pitch*a);
    state.pitch = state.ema.pitch;
  }
  if (typeof e.webkitCompassAccuracy === "number"){
    const acc=e.webkitCompassAccuracy;
    state.field = 1/(acc+1);
    magBadge.textContent = (acc<20)? "Mag OK":"Mag noisy";
  }
  state.smp++; const now=performance.now();
  if(now - state.t0 > 1000){ state.hz=state.smp; state.smp=0; state.t0=now; }
}

/* ===== Target / compute ===== */
function setTargetAzEl(az,el,distKm=null){
  state.target.has=true; state.target.az=wrap360(az); state.target.el=el;
  if(distKm!=null) state.target.distKm=distKm;
  targetChip.textContent = `Target: Az ${state.target.az.toFixed(1)}¬∞, El ${state.target.el.toFixed(1)}¬∞`;
  render();
}
function computeFromCoords(){
  const alat=parseFloat($("#alat").value), alon=parseFloat($("#alon").value);
  const blat=parseFloat($("#blat").value), blon=parseFloat($("#blon").value);
  const aAGL=parseFloat($("#aAGL").value)||0, bAGL=parseFloat($("#bAGL").value)||0;
  const aGround=parseFloat($("#aGround").value)||0, bGround=parseFloat($("#bGround").value)||0;
  if([alat,alon,blat,blon].some(v=>Number.isNaN(v))) return;
  const A={lat:alat,lon:alon,agl:aAGL,ground:aGround}, B={lat:blat,lon:blon,agl:bAGL,ground:bGround};
  const Dm=haversine(A,B); const az=bearing(A,B);
  const {el,drop}=aimElevation(A,B,Dm,parseFloat($("#kInput").value)||1.333);
  const fGHz=parseFloat($("#freqInput").value)||5.8;
  const f1=fresnelF1mid(Dm/1000,fGHz);
  $("#computedAz").textContent=az.toFixed(1); $("#computedEl").textContent=el.toFixed(2);
  $("#f1Lbl").textContent=fmtF1(f1, state.units); $("#dropLbl").textContent=drop.toFixed(2);
  state.target.a=A; state.target.b=B; setTargetAzEl(az,el,Dm/1000);
}

/* ===== Floating menus & inputs ===== */
const backdrop=$("#backdrop");
function openSheet(id){ backdrop.classList.add("show"); $("#"+id).classList.add("open"); }
function closeSheet(id){ $("#"+id).classList.remove("open"); setTimeout(()=>{ if(!document.querySelector(".sheet.open")) backdrop.classList.remove("show"); },150); }
backdrop.addEventListener("click", ()=>document.querySelectorAll(".sheet.open").forEach(s=>s.classList.remove("open")) || backdrop.classList.remove("show"));
document.querySelectorAll(".closeX").forEach(b=>b.addEventListener("click", e=>closeSheet(e.currentTarget.dataset.close)));
$("#fabTarget").addEventListener("click", ()=>openSheet("sheetTarget"));
$("#fabSensors").addEventListener("click", ()=>openSheet("sheetSensors"));
$("#fabOptions").addEventListener("click", ()=>openSheet("sheetOptions"));
$("#fabPresets").addEventListener("click", ()=>openSheet("sheetPresets"));

const targetTabs=$("#targetTabs");
targetTabs.addEventListener("click", e=>{
  if(e.target.tagName!=="BUTTON") return;
  targetTabs.querySelectorAll("button").forEach(b=>b.classList.remove("active"));
  e.target.classList.add("active");
  const tab=e.target.dataset.tab;
  $("#tabAzEl").style.display = (tab==="azEl")?"block":"none";
  $("#tabCoords").style.display = (tab==="coords")?"block":"none";
});
$("#btnSetTargetAzEl").addEventListener("click", ()=>{ const az=parseFloat($("#azInput").value), el=parseFloat($("#elInput").value); if(isFinite(az)&&isFinite(el)) setTargetAzEl(az,el); });
$("#btnPaste").addEventListener("click", async ()=>{ try{ const t=await navigator.clipboard.readText(); $("#pasteBox").value=t || $("#pasteBox").value; }catch(e){} });
$("#btnParse").addEventListener("click", ()=>{
  const t=$("#pasteBox").value.trim(); if(!t) return;
  const nums=t.match(/-?\d+(\.\d+)?/g)?.map(Number)||[];
  if(nums.length>=10){
    $("#alat").value=nums[0]; $("#alon").value=nums[1]; $("#aAGL").value=nums[2]; $("#aGround").value=nums[3];
    $("#blat").value=nums[4]; $("#blon").value=nums[5]; $("#bAGL").value=nums[6]; $("#bGround").value=nums[7];
    $("#azInput").value=nums[8]; $("#elInput").value=nums[9];
  } else if(nums.length>=2){ $("#azInput").value=nums[0]; $("#elInput").value=nums[1]; }
});
$("#btnCompute").addEventListener("click", computeFromCoords);

/* Options bindings */
$("#tolAz").addEventListener("input", e=>state.tolAz=parseFloat(e.target.value)||2);
$("#tolEl").addEventListener("input", e=>state.tolEl=parseFloat(e.target.value)||1);
$("#freqInput").addEventListener("input", e=>{ state.freq=parseFloat(e.target.value)||5.8; if(state.target.a&&state.target.b) computeFromCoords(); });
$("#kInput").addEventListener("input", e=>{ state.K=parseFloat(e.target.value)||1.333; if(state.target.a&&state.target.b) computeFromCoords(); });
$("#fresnelWarn").addEventListener("change", e=>state.fresnelWarn=parseFloat(e.target.value)||0.6);
$("#unitSelect").addEventListener("change", e=>{ state.units=e.target.value; });
$("#largeText").addEventListener("change", e=>document.body.classList.toggle("largeText", e.target.checked));
$("#haptics").addEventListener("change", e=>state.haptics=e.target.checked);

/* Presets */
function refreshPresets(){
  const store = JSON.parse(localStorage.getItem("azalign_presets")||"{}");
  $("#presetSelect").innerHTML = `<option value="">Select preset‚Ä¶</option>` + Object.keys(store).map(k=>`<option>${k}</option>`).join("");
}
$("#btnSavePreset").addEventListener("click", ()=>{
  const name=prompt("Preset name?"); if(!name) return;
  const preset={
    az:parseFloat($("#azInput").value), el:parseFloat($("#elInput").value),
    A:{lat:parseFloat($("#alat").value),lon:parseFloat($("#alon").value),agl:parseFloat($("#aAGL").value),ground:parseFloat($("#aGround").value)},
    B:{lat:parseFloat($("#blat").value),lon:parseFloat($("#blon").value),agl:parseFloat($("#bAGL").value),ground:parseFloat($("#bGround").value)},
    k:parseFloat($("#kInput").value), f:parseFloat($("#freqInput").value),
    decl:parseFloat($("#declInput").value), mode:$("#modeSelect").value,
    units:state.units, tolAz:state.tolAz, tolEl:state.tolEl
  };
  const store=JSON.parse(localStorage.getItem("azalign_presets")||"{}"); store[name]=preset;
  localStorage.setItem("azalign_presets", JSON.stringify(store)); refreshPresets();
});
$("#btnLoadPreset").addEventListener("click", ()=>{
  const key=$("#presetSelect").value; if(!key) return;
  const store=JSON.parse(localStorage.getItem("azalign_presets")||"{}"); const p=store[key]; if(!p) return;
  $("#azInput").value=p.az??0; $("#elInput").value=p.el??0;
  if(p.A){ $("#alat").value=p.A.lat??""; $("#alon").value=p.A.lon??""; $("#aAGL").value=p.A.agl??""; $("#aGround").value=p.A.ground??""; }
  if(p.B){ $("#blat").value=p.B.lat??""; $("#blon").value=p.B.lon??""; $("#bAGL").value=p.B.agl??""; $("#bGround").value=p.B.ground??""; }
  $("#kInput").value=p.k??1.333; $("#freqInput").value=p.f??5.8; $("#declInput").value=p.decl??0; $("#modeSelect").value=p.mode??"true";
  state.units=p.units||"metric"; $("#unitSelect").value=state.units; state.tolAz=p.tolAz??2; state.tolEl=p.tolEl??1;
  refreshPresets(); render();
});
$("#btnExport").addEventListener("click", ()=>{ $("#jsonBox").value = localStorage.getItem("azalign_presets")||"{}"; });
$("#btnImport").addEventListener("click", ()=>{ try{ const obj=JSON.parse($("#jsonBox").value||"{}"); localStorage.setItem("azalign_presets", JSON.stringify(obj)); refreshPresets(); alert("Imported."); }catch{ alert("Invalid JSON"); }});
refreshPresets();

/* ===== Radar map (in-compass) ===== */
const Radar = (() => {
  // simple local projection around user's current position (azimuthal equidistant approx)
  let follow=true, rotate=false;
  let zoomIdx=2; // scales index
  const scales = [0.25, 0.5, 1, 2, 4]; // km per ring step
  let longPressTimer=null, pressPt=null, lastPt=null;

  const wayKey='radar.waypoints.v1';
  function loadWPs(){ try{return JSON.parse(localStorage.getItem(wayKey)||'[]');}catch{return[]} }
  function saveWPs(a){ try{localStorage.setItem(wayKey, JSON.stringify(a));}catch{} }

  function setFollow(v){ follow=v; $("#btnFollow").classList.toggle('toggled', follow); }
  function setRotate(v){ rotate=v; $("#btnRotate").classList.toggle('toggled', rotate); }

  function init(){
    setFollow(true); setRotate(false);
    $("#btnFollow").addEventListener("click", ()=>setFollow(!follow));
    $("#btnRotate").addEventListener("click", ()=>setRotate(!rotate));
    $("#zoomIn").addEventListener("click", ()=>{ zoomIdx=Math.min(scales.length-1, zoomIdx+1); });
    $("#zoomOut").addEventListener("click", ()=>{ zoomIdx=Math.max(0, zoomIdx-1); });

    // Waypoints popover (very light)
    $("#btnWaypoints").addEventListener("click", ()=>{
      const name=prompt("Add waypoint: name (or leave blank to manage existing)")||"";
      if(name){
        const coords=prompt("lat,lon (e.g., 34.123,-118.456)")||"";
        const m=coords.match(/-?\d+(\.\d+)?/g); if(!m||m.length<2) return alert("Bad coords");
        const lat=parseFloat(m[0]), lon=parseFloat(m[1]);
        const all=loadWPs(); all.push({name,lat,lon}); saveWPs(all);
      }else{
        const all=loadWPs(); if(all.length===0) return alert("No waypoints yet.");
        const list=all.map((w,i)=>`${i+1}. ${w.name} (${w.lat.toFixed(5)},${w.lon.toFixed(5)})`).join('\n');
        const pick=prompt(`Waypoints:\n${list}\n\nType number to GUIDE, or 0 to DELETE all:`) || "";
        const idx=parseInt(pick,10);
        if(idx===0){ if(confirm("Delete all?")) saveWPs([]); }
        if(Number.isFinite(idx) && idx>=1 && idx<=all.length){
          const w=all[idx-1];
          guideTo({lat:w.lat,lon:w.lon}, w.name);
        }
      }
    });

    // Interactions: long press inside circle to drop a pin at relative bearing
    radar.addEventListener('pointerdown', e=>{
      pressPt=getPt(e); lastPt=pressPt;
      clearTimeout(longPressTimer);
      longPressTimer=setTimeout(()=>{ longPressTimer=null; onLongPress(lastPt); }, 380);
    });
    radar.addEventListener('pointermove', e=>{
      if(!longPressTimer) return;
      lastPt=getPt(e);
      if(dist2(lastPt,pressPt) > 14*14){ clearTimeout(longPressTimer); longPressTimer=null; }
    });
    ['pointerup','pointerleave','pointercancel'].forEach(ev=>radar.addEventListener(ev, ()=>{ clearTimeout(longPressTimer); longPressTimer=null; }));

    requestAnimationFrame(draw);
  }

  function getPt(e){
    const r=radar.getBoundingClientRect();
    return {x:e.clientX - r.left, y:e.clientY - r.top};
  }
  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

  function onLongPress(pt){
    const {cx,cy,R}=geom();
    const dx=pt.x-cx, dy=pt.y-cy;
    const r=Math.hypot(dx,dy); if(r>R) return; // outside
    // angle screen (0 right, CCW), convert to compass heading
    const ang = Math.atan2(dy,dx); // radians
    // if rotate=true, screen already rotates with heading; to get true map bearing:
    const baseHead = state.heading||0;
    let bearingDeg = (toDeg(ang)<0? toDeg(ang)+360: toDeg(ang)); // 0..360, 0=east
    bearingDeg = (90 - bearingDeg + 360) % 360; // convert: 0=north, clockwise
    if(rotate) bearingDeg = (bearingDeg + baseHead) % 360;

    // distance from center: map to km via current scale (R corresponds to ~2 ring steps)
    const stepKm = scales[zoomIdx];
    const ringMaxKm = stepKm*3; // 3 rings
    const dKm = clamp((r/R)*ringMaxKm, 0, ringMaxKm);
    // build target lat/lon from you + bearing + distance
    if(state.you.lat==null){ alert("Need GPS fix first."); return; }
    const dest = destLL({lat:state.you.lat,lon:state.you.lon}, bearingDeg, dKm*1000);
    guideTo(dest, `Pin ${dest.lat.toFixed(5)},${dest.lon.toFixed(5)}`);
  }

  function destLL(A, bDeg, dMeters){
    const br=toRad(bDeg), dr=dMeters/6371000, lat1=toRad(A.lat), lon1=toRad(A.lon);
    const lat2=Math.asin(Math.sin(lat1)*Math.cos(dr)+Math.cos(lat1)*Math.sin(dr)*Math.cos(br));
    const lon2=lon1+Math.atan2(Math.sin(br)*Math.sin(dr)*Math.cos(lat1), Math.cos(dr)-Math.sin(lat1)*Math.sin(lat2));
    return {lat:toDeg(lat2), lon:((toDeg(lon2)+540)%360)-180};
  }

  function guideTo(B, name="Dest"){
    // set as radar destination AND main target (computes Az/El)
    const A={lat:state.you.lat, lon:state.you.lon, agl:parseFloat($("#aAGL").value)||0, ground:parseFloat($("#aGround").value)||0};
    const Dm=haversine(A,{lat:B.lat,lon:B.lon});
    const az=bearing(A,{lat:B.lat,lon:B.lon});
    const {el}=aimElevation(A,{lat:B.lat,lon:B.lon,agl:parseFloat($("#bAGL").value)||0, ground:parseFloat($("#bGround").value)||0}, Dm, parseFloat($("#kInput").value)||1.333);
    state.target.a=A; state.target.b={lat:B.lat,lon:B.lon, agl:parseFloat($("#bAGL").value)||0, ground:parseFloat($("#bGround").value)||0};
    setTargetAzEl(az, el, Dm/1000);
    // flash small confirmation
    const lbl=$("#radarDistLbl"); lbl.textContent = `${fmtDist(Dm/1000, state.units)} ¬∑ ${az.toFixed(1)}¬∞`; lbl.style.color="#fff"; setTimeout(()=>lbl.style.color="",800);
  }

  function geom(){
    const w=radar.clientWidth, h=radar.clientHeight;
    radar.width = w*devicePixelRatio; radar.height = h*devicePixelRatio;
    rctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    const cx=w/2, cy=h/2; const R=Math.min(w,h)/2-8; // inner radius
    return {w,h,cx,cy,R};
  }

  function draw(){
    const {w,h,cx,cy,R}=geom();
    // clear
    rctx.clearRect(0,0,w,h);
    // clip to circle (compass)
    rctx.save();
    rctx.beginPath(); rctx.arc(cx,cy,R,0,Math.PI*2); rctx.clip();

    // background subtle grid
    rctx.fillStyle="#0b1319"; rctx.fillRect(0,0,w,h);

    // transform for rotation
    rctx.translate(cx,cy);
    const heading = state.heading||0;
    if(rotate){ rctx.rotate(-toRad(heading)); }

    // rings
    rctx.strokeStyle="rgba(255,255,255,.09)"; rctx.lineWidth=1;
    const stepKm=scales[zoomIdx]; const rings=3;
    for(let i=1;i<=rings;i++){
      const r = (R * i)/rings;
      rctx.beginPath(); rctx.arc(0,0,r,0,Math.PI*2); rctx.stroke();
    }
    // radial lines (N/E/S/W)
    rctx.strokeStyle="rgba(255,255,255,.12)";
    for(let a=0;a<360;a+=90){ const ang=toRad(90-a); rctx.beginPath(); rctx.moveTo(0,0); rctx.lineTo(Math.cos(ang)*R, Math.sin(ang)*R); rctx.stroke(); }

    // you (center)
    rctx.fillStyle="#9ad3ff"; rctx.beginPath(); rctx.arc(0,0,4,0,Math.PI*2); rctx.fill();

    // target waypoint line
    if(state.target.has && state.target.b && state.you.lat!=null){
      const brg = bearing({lat:state.you.lat,lon:state.you.lon}, {lat:state.target.b.lat, lon:state.target.b.lon});
      const dist = haversine({lat:state.you.lat,lon:state.you.lon}, {lat:state.target.b.lat,lon:state.target.b.lon});
      const ringMaxKm = stepKm*3;
      const r = clamp((dist/1000)/ringMaxKm, 0, 1) * R;
      const ang = toRad(90 - brg);
      const tx = Math.cos(ang)*r, ty=Math.sin(ang)*r;

      // guide line
      rctx.strokeStyle="rgba(42,193,138,.95)"; rctx.lineWidth=2;
      rctx.beginPath(); rctx.moveTo(0,0); rctx.lineTo(tx,ty); rctx.stroke();

      // target dot
      rctx.fillStyle="#ffcc66"; rctx.beginPath(); rctx.arc(tx,ty,5,0,Math.PI*2); rctx.fill();

      // label
      rctx.save(); rctx.translate(tx,ty); rctx.rotate(-rctx.getTransform().a); rctx.fillStyle="rgba(0,0,0,.35)";
      rctx.restore();

      // footer readout chip
      const lbl = `${fmtDist(dist/1000, state.units)} ¬∑ ${brg.toFixed(1)}¬∞`;
      $("#radarDistLbl").textContent = lbl;
    } else {
      $("#radarDistLbl").textContent = "‚Äî";
    }

    // heading ray
    if(state.heading!=null){
      const ang = toRad(90 - (state.heading)); // north up
      rctx.strokeStyle="#2aff2a"; rctx.lineWidth=2;
      rctx.beginPath(); rctx.moveTo(0,0); rctx.lineTo(Math.cos(ang)*R, Math.sin(ang)*R); rctx.stroke();
    }

    // unclip & finish
    rctx.restore();

    // follow: keep you at center (visual), nothing to pan anyway

    render(); // update numbers/colors
    requestAnimationFrame(draw);
  }

  return { init };
})();

/* ===== Kick ===== */
document.getElementById("startBtn").addEventListener("click", startSensors);
document.getElementById("modeSelect").addEventListener("change", ()=>render());
["declInput","azOffset","elOffset","alphaAz","alphaEl"].forEach(id=>$("#"+id).addEventListener("input", ()=>{ state.ema.heading=null; state.ema.pitch=null; render(); }));

// Resize radar canvas to compass
function sizeRadar(){
  const rect = compass.getBoundingClientRect();
  const cs = getComputedStyle(compass);
  const w = rect.width - parseFloat(cs.borderLeftWidth) - parseFloat(cs.borderRightWidth);
  const h = rect.height - parseFloat(cs.borderTopWidth) - parseFloat(cs.borderBottomWidth);
  radar.style.width = w+"px"; radar.style.height = h+"px";
}
window.addEventListener("resize", sizeRadar);
sizeRadar();
Radar.init();
statusBadge.textContent="Ready";
</script>
</body>
</html>
