<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b1020" />
  <title>3D Live Phone Orientation</title>
  <style>
    :root {
      --bg: radial-gradient(1200px 800px at 20% 10%, #1e2a5a 0%, #0b1020 60%);
      --panel: rgba(255,255,255,0.06);
      --border: rgba(255,255,255,0.1);
      --text: #e8eefc;
      --muted: #9fb2e3;
      --accent: #6aa1ff;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: #0b1020;
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }
    #scene {
      position: fixed; inset: 0; width: 100%; height: 100%; display: block; background: var(--bg);
    }
    .overlay {
      position: fixed; inset: 0; pointer-events: none; display: grid; place-items: start center; padding: env(safe-area-inset-top) 16px 16px;
    }
    .hud {
      pointer-events: auto; margin-top: 12px; display: flex; gap: 12px; align-items: center; background: var(--panel);
      border: 1px solid var(--border); backdrop-filter: blur(10px); border-radius: 14px; padding: 10px 14px; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    .hud small { color: var(--muted); }
    .hud .sep { width: 1px; height: 20px; background: var(--border); }
    .hud input[type=range] { accent-color: var(--accent); }
    .hud button {
      appearance: none; border: 1px solid var(--border); background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
      color: var(--text); padding: 8px 12px; border-radius: 12px; cursor: pointer; font-weight: 600;
    }
    .hud button:hover { filter: brightness(1.1); }

    .center-modal {
      position: fixed; inset: 0; display: grid; place-items: center; background: rgba(3,6,16,0.72);
      backdrop-filter: blur(6px); z-index: 10; padding: 24px; transition: opacity 200ms ease;
    }
    .card { pointer-events: auto; width: min(520px, 92vw); border-radius: 18px; border: 1px solid var(--border); background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04)); padding: 22px 22px 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.4); }
    .card h1 { margin: 0 0 6px; font-size: 20px; letter-spacing: 0.2px; }
    .card p { margin: 0 0 14px; color: var(--muted); line-height: 1.4; }
    .cta-row { display: flex; gap: 10px; flex-wrap: wrap; }
    .cta-row button, .cta-row a {
      appearance: none; border: 1px solid var(--border); text-decoration: none; color: var(--text);
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      padding: 10px 14px; border-radius: 12px; cursor: pointer; font-weight: 700;
    }
    .cta-row button.primary { background: linear-gradient(180deg, rgba(121,169,255,0.6), rgba(55,123,255,0.45)); border-color: rgba(147,183,255,0.5); }
    .hidden { opacity: 0; pointer-events: none; }

    .badge { padding: 2px 8px; border-radius: 999px; background: rgba(255,255,255,0.1); border: 1px solid var(--border); font-size: 11px; color: var(--muted); }
  </style>
</head>
<body>
  <canvas id="scene" aria-label="3D phone orientation"></canvas>

  <!-- HUD overlay -->
  <div class="overlay" aria-live="polite" aria-atomic="true">
    <div class="hud">
      <span class="badge" id="status">awaiting sensors…</span>
      <div class="sep"></div>
      <small>α:<span id="alpha">–</span>° β:<span id="beta">–</span>° γ:<span id="gamma">–</span>°</small>
      <div class="sep"></div>
      <small>smooth</small>
      <input id="smooth" type="range" min="0" max="0.3" step="0.01" value="0.08" title="Smoothing" />
      <button id="recenter" title="Set current as forward">Recenter</button>
    </div>
  </div>

  <!-- Permission / Fallback modal -->
  <div id="permModal" class="center-modal">
    <div class="card">
      <h1>Enable Motion Access</h1>
      <p>
        To render your phone in 3D using live orientation, we need motion sensor permission. Works over HTTPS (GitHub Pages).
      </p>
      <div class="cta-row">
        <button id="enableBtn" class="primary">Enable Motion</button>
        <button id="mouseBtn">Use Mouse Instead</button>
        <a href="#" id="learnLink" aria-label="What data is used?">What’s collected?</a>
      </div>
      <p style="margin-top:10px"><small class="badge">Privacy</small> This page reads only orientation angles from your device; no data leaves your browser.</p>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { RoundedBoxGeometry } from 'https://unpkg.com/three@0.160.0/examples/jsm/geometries/RoundedBoxGeometry.js';

    // --- Renderer / Scene / Camera ---
    const canvas = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);

    const scene = new THREE.Scene();
    scene.background = null; // keep CSS gradient

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.05, 100);
    camera.position.set(0.35, 0.25, 0.6);

    // Lighting
    {
      const amb = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(amb);
      const key = new THREE.DirectionalLight(0xffffff, 0.8);
      key.position.set(1, 1.2, 0.8);
      scene.add(key);
      const rim = new THREE.DirectionalLight(0xffffff, 0.5);
      rim.position.set(-1.2, 0.3, -1);
      scene.add(rim);
    }

    // Ground + helpers
    {
      const grid = new THREE.GridHelper(4, 32, 0x777777, 0x333333);
      grid.position.y = -0.18;
      scene.add(grid);
      const axes = new THREE.AxesHelper(0.18);
      axes.position.set(0.0, -0.18, 0);
      scene.add(axes);
    }

    // Phone model
    const phone = new THREE.Group();
    scene.add(phone);
    (function buildPhone(){
      const bodyGeo = new RoundedBoxGeometry(0.15, 0.30, 0.010, 7, 0.012);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x222b3a, metalness: 0.6, roughness: 0.35 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.castShadow = true; body.receiveShadow = true;
      phone.add(body);

      const screenGeo = new RoundedBoxGeometry(0.138, 0.288, 0.003, 6, 0.010);
      const screenMat = new THREE.MeshStandardMaterial({ color: 0x0b0f18, metalness: 0.0, roughness: 0.9, emissive: 0x050a14, emissiveIntensity: 0.6 });
      const screen = new THREE.Mesh(screenGeo, screenMat);
      screen.position.z = 0.006;
      phone.add(screen);

      const axes = new THREE.AxesHelper(0.08);
      axes.position.set(0,0,0.006);
      phone.add(axes);

      // Decorative notch (top center)
      const notchGeo = new RoundedBoxGeometry(0.032, 0.012, 0.003, 4, 0.004);
      const notchMat = new THREE.MeshStandardMaterial({ color: 0x0e1220, metalness: 0.1, roughness: 0.7 });
      const notch = new THREE.Mesh(notchGeo, notchMat);
      notch.position.set(0, 0.133, 0.0065);
      phone.add(notch);

      // Tilt the whole thing slightly initially for desktop view
      phone.rotation.set(0.2, -0.3, 0.05);
      phone.position.y = 0.0;
    })();

    // OrbitControls fallback (desktop)
    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.enableDamping = true;
    orbit.enabled = false; // start disabled; enabled if no sensors/permission denied

    // HUD elements
    const statusEl = document.getElementById('status');
    const alphaEl = document.getElementById('alpha');
    const betaEl  = document.getElementById('beta');
    const gammaEl = document.getElementById('gamma');
    const smoothEl = document.getElementById('smooth');
    const recenterBtn = document.getElementById('recenter');
    const permModal = document.getElementById('permModal');
    const enableBtn = document.getElementById('enableBtn');
    const mouseBtn = document.getElementById('mouseBtn');
    const learnLink = document.getElementById('learnLink');

    learnLink.addEventListener('click', (e) => {
      e.preventDefault();
      alert('This page only reads orientation angles (alpha, beta, gamma) locally to rotate the 3D model. Nothing is transmitted.');
    });

    // Motion handling state
    const targetQ = new THREE.Quaternion();
    const displayQ = new THREE.Quaternion();
    let baselineQ = new THREE.Quaternion().identity(); // inverse of current to recenter
    let haveReading = false;
    let smoothing = parseFloat(smoothEl.value);

    const zee = new THREE.Vector3(0,0,1);
    const euler = new THREE.Euler();
    const q0 = new THREE.Quaternion();
    const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // -PI/2 around X

    function getScreenOrientationRad() {
      const ang = (screen.orientation && typeof screen.orientation.angle === 'number') ? screen.orientation.angle : (window.orientation || 0);
      return THREE.MathUtils.degToRad(ang || 0);
    }

    function setObjectQuaternionFromEuler(q, alpha, beta, gamma, orient) {
      // Replicates three.js DeviceOrientationControls mapping
      euler.set(beta, alpha, -gamma, 'YXZ');
      q.setFromEuler(euler);
      q.multiply(q1);
      q.multiply(q0.setFromAxisAngle(zee, -orient));
    }

    function handleDeviceOrientation(ev) {
      const { alpha, beta, gamma } = ev;
      if (alpha == null || beta == null || gamma == null) return;
      haveReading = true;
      const a = THREE.MathUtils.degToRad(alpha);
      const b = THREE.MathUtils.degToRad(beta);
      const g = THREE.MathUtils.degToRad(gamma);
      setObjectQuaternionFromEuler(targetQ, a, b, g, getScreenOrientationRad());

      // HUD
      alphaEl.textContent = (alpha).toFixed(0);
      betaEl.textContent  = (beta ).toFixed(0);
      gammaEl.textContent = (gamma).toFixed(0);
    }

    function onPermissionGranted() {
      window.addEventListener('deviceorientation', handleDeviceOrientation, true);
      statusEl.textContent = 'live';
      statusEl.style.color = '#9cf3b2';
      permModal.classList.add('hidden');
      orbit.enabled = false;
    }

    async function requestPermissionIfNeeded() {
      // iOS 13+ requires explicit permission; other platforms may not
      const iOSNeedsPermission = typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function';
      if (iOSNeedsPermission) {
        try {
          // Some iOS versions also require DeviceMotion; ignore errors there
          if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
            try { await DeviceMotionEvent.requestPermission(); } catch {}
          }
          const state = await DeviceOrientationEvent.requestPermission();
          if (state === 'granted') { onPermissionGranted(); }
          else { throw new Error('Permission denied'); }
        } catch (err) {
          statusEl.textContent = 'permission denied';
          statusEl.style.color = '#ff8a80';
          orbit.enabled = true;
        }
      } else {
        // Non‑iOS
        if ('DeviceOrientationEvent' in window) {
          onPermissionGranted();
        } else {
          statusEl.textContent = 'no sensor';
          statusEl.style.color = '#ffd27f';
          orbit.enabled = true;
        }
      }
    }

    // UI wiring
    enableBtn.addEventListener('click', () => requestPermissionIfNeeded());
    mouseBtn.addEventListener('click', () => { orbit.enabled = true; permModal.classList.add('hidden'); statusEl.textContent = 'mouse'; });
    smoothEl.addEventListener('input', () => { smoothing = parseFloat(smoothEl.value); });
    recenterBtn.addEventListener('click', () => {
      // Make current orientation the new forward (identity)
      baselineQ.copy(targetQ).invert();
    });

    // Resize handling
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    });

    // Screen orientation changes affect mapping
    const onSO = () => {};
    if (screen.orientation && screen.orientation.addEventListener) {
      screen.orientation.addEventListener('change', onSO);
    } else {
      addEventListener('orientationchange', onSO);
    }

    // Animation loop
    const tmpQ = new THREE.Quaternion();
    function animate() {
      requestAnimationFrame(animate);

      // If we have device data, compute relative quaternion baseline * target
      if (haveReading) {
        tmpQ.copy(baselineQ).multiply(targetQ);
        // Smooth the visual rotation
        THREE.Quaternion.slerp(phone.quaternion, tmpQ, phone.quaternion, 1 - Math.exp(-60 * smoothing * (renderer.info.render.frameTime || 0.016)));
      }

      orbit.update();
      renderer.render(scene, camera);
    }
    animate();

    // Secure context check
    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
      statusEl.textContent = 'HTTPS required';
      statusEl.style.color = '#ffd27f';
    }

    // Hint: auto-attempt on Android to avoid extra tap, keep modal visible on iOS
    (async function autoTry() {
      const iOSNeedsPermission = typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function';
      if (!iOSNeedsPermission) {
        await requestPermissionIfNeeded();
      }
    })();
  </script>
</body>
</html>
