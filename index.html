<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no"
  />
  <title>3D Spatial Compass — Precision Alignment Tool</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background: #000; color: #fff;
      height: 100%; width: 100%;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      touch-action: none; -webkit-user-select: none; user-select: none;
    }
    #info {
      position: fixed; top: 10px; left: 10px; right: 120px;
      font-size: 14px; line-height: 1.35; opacity: 0.9; z-index: 10;
      text-shadow: 0 0 4px #000;
    }
    #menuButton {
      position: fixed; top: 10px; right: 10px; z-index: 10;
      padding: 8px 12px; font-size: 15px;
      background: rgba(50,50,50,0.9); color: #fff;
      border: 1px solid #777; border-radius: 6px;
    }
    #menuOverlay {
      position: fixed; inset: 0;
      display: none; z-index: 20;
      background: rgba(0,0,0,0.95); color: #fff;
      padding: 20px; box-sizing: border-box;
      display: none; flex-direction: column; align-items: center; justify-content: center;
    }
    #menuOverlay h2 { margin: 0 0 12px 0; }
    #menuOverlay input {
      width: 85%; padding: 10px; margin: 7px 0;
      font-size: 16px; border: none; border-radius: 6px;
      background: #1e1e1e; color: #fff;
    }
    #menuOverlay button {
      margin: 7px 0; padding: 10px 14px; font-size: 16px;
      border: 1px solid #555; background: #333; color: #fff; border-radius: 6px;
    }
    #waypointList {
      width: 85%; max-height: 200px; overflow-y: auto;
      border: 1px solid #333; padding: 6px; margin-top: 8px; border-radius: 6px;
      font-size: 14px;
    }
    .wpItem {
      padding: 6px; border-bottom: 1px solid #444; cursor: pointer;
    }
    .wpItem:last-child { border-bottom: none; }
    .wpItem:hover { background: rgba(255,255,255,0.08); }
  </style>
</head>
<body>
  <div id="info">Initializing… Allow motion/orientation & location when prompted.</div>
  <button id="menuButton">Set Target</button>

  <div id="menuOverlay">
    <h2>Target Point</h2>
    <input id="wpLat" type="number" step="any" placeholder="Latitude (e.g. 34.8234)">
    <input id="wpLng" type="number" step="any" placeholder="Longitude (e.g. -118.9453)">
    <input id="wpElev" type="number" step="any" placeholder="Elevation (m)">
    <button id="fetchElev">Fetch Elevation</button>
    <button id="setTarget">Set Target</button>
    <div id="waypointList"></div>
    <button id="closeMenu">Close</button>
  </div>

  <!-- Three.js (r160) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    // ===================== Global state =====================
    let scene, camera, renderer;
    let realArrow, targetArrow, azimuthRing, pitchRing;
    let deviceQuat = new THREE.Quaternion();
    let rollIndependentQuat = new THREE.Quaternion();

    const EARTH_RADIUS = 6371000; // meters
    const ALIGN_TOLERANCE_DEG = 2; // alignment threshold
    const infoEl = document.getElementById('info');

    let currentPos = { lat: null, lon: null, elev: 0 };
    let target = null; // { lat, lon, elev }

    // ===================== Math helpers =====================
    const deg2rad = d => d * Math.PI / 180;
    const rad2deg = r => r * 180 / Math.PI;

    // Great-circle distance (meters)
    function distanceMeters(lat1, lon1, lat2, lon2) {
      const φ1 = deg2rad(lat1), φ2 = deg2rad(lat2);
      const Δφ = φ2 - φ1, Δλ = deg2rad(lon2 - lon1);
      const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
      return 2 * EARTH_RADIUS * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    // Initial bearing (degrees), 0 = North, clockwise
    function bearingTo(lat1, lon1, lat2, lon2) {
      const φ1 = deg2rad(lat1), φ2 = deg2rad(lat2);
      const Δλ = deg2rad(lon2 - lon1);
      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
      return (rad2deg(Math.atan2(y, x)) + 360) % 360;
    }

    // Elevation (pitch) angle to target, degrees
    function elevationAngle(lat1, lon1, elev1, lat2, lon2, elev2) {
      const Δe = (elev2 ?? 0) - (elev1 ?? 0);
      const dist = distanceMeters(lat1, lon1, lat2, lon2);
      return rad2deg(Math.atan2(Δe, dist));
    }

    // Direction vector (world) from bearing & elevation
    function dirFromBearingElevation(bearingDeg, elevDeg) {
      const yaw = deg2rad(bearingDeg);
      const pitch = deg2rad(elevDeg);
      const x = Math.sin(yaw) * Math.cos(pitch);
      const y = Math.sin(pitch);
      const z = -Math.cos(yaw) * Math.cos(pitch);
      return new THREE.Vector3(x, y, z).normalize();
    }

    // Quaternion that orients +Y to the provided direction vector
    function quatToPointPlusY(dirVec) {
      return new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dirVec);
    }

    // ===================== Elevation service =====================
    async function fetchElevation(lat, lon) {
      try {
        const url = `https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lon}`;
        const r = await fetch(url);
        const j = await r.json();
        if (j && j.results && j.results.length) return j.results[0].elevation;
      } catch (e) {
        console.warn('Elevation fetch error:', e);
      }
      return null;
    }

    // ===================== Scene setup =====================
    function initScene() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 5);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Real heading arrow: cone along +Y
      const arrowGeom = new THREE.ConeGeometry(0.22, 1.1, 40);
      const realMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.85 });
      realArrow = new THREE.Mesh(arrowGeom, realMat);
      realArrow.rotation.x = Math.PI / 2;
      scene.add(realArrow);

      // Target arrow: identical, toggled visible after a target is set
      const tgtMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.85 });
      targetArrow = new THREE.Mesh(arrowGeom, tgtMat);
      targetArrow.rotation.x = Math.PI / 2;
      targetArrow.visible = false;
      scene.add(targetArrow);

      // Azimuth ring (XY plane) with ticks and labels
      azimuthRing = makeRingWithTicks(1.85, 120, 0x00ffff, 0.28, /*vertical=*/false);
      scene.add(azimuthRing.group);
      addCardinalLabels(azimuthRing.radius);

      // Pitch ring (vertical / YZ plane)
      pitchRing = makeRingWithTicks(1.25, 80, 0xff00ff, 0.28, /*vertical=*/true);
      scene.add(pitchRing.group);

      window.addEventListener('resize', onResize);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Create a thin ring + tick marks; if vertical=true it rotates into YZ plane
    function makeRingWithTicks(radius, segments, color, opacity, vertical=false) {
      const group = new THREE.Group();

      // The ring line
      const curve = new THREE.EllipseCurve(
        0, 0, radius, radius, 0, Math.PI * 2, false, 0
      );
      const pts = curve.getPoints(segments);
      const geom = new THREE.BufferGeometry().setFromPoints(pts.map(p => new THREE.Vector3(p.x, p.y, 0)));
      const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity });
      const ring = new THREE.LineLoop(geom, mat);
      group.add(ring);

      // Tick marks every 10°
      for (let deg = 0; deg < 360; deg += 10) {
        const a = deg2rad(deg);
        const rOuter = radius;
        const rInner = radius - (deg % 90 === 0 ? 0.12 : 0.07); // longer ticks at N/E/S/W
        const x1 = Math.cos(a) * rOuter, y1 = Math.sin(a) * rOuter;
        const x2 = Math.cos(a) * rInner, y2 = Math.sin(a) * rInner;

        const tickGeom = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(x1, y1, 0),
          new THREE.Vector3(x2, y2, 0)
        ]);
        const tick = new THREE.Line(tickGeom, new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.45 }));
        group.add(tick);
      }

      if (vertical) group.rotation.x = Math.PI / 2;
      return { group, radius };
    }

    function addCardinalLabels(radius) {
      // Simple Canvas-based text sprites (N/E/S/W) around azimuth ring
      const labels = [
        { txt: 'N', pos: new THREE.Vector3(0,  radius + 0.10, 0) },
        { txt: 'E', pos: new THREE.Vector3( radius + 0.10, 0, 0) },
        { txt: 'S', pos: new THREE.Vector3(0, -radius - 0.10, 0) },
        { txt: 'W', pos: new THREE.Vector3(-radius - 0.10, 0, 0) },
      ];
      for (const { txt, pos } of labels) {
        const sprite = makeTextSprite(txt);
        sprite.position.copy(pos);
        scene.add(sprite);
      }
    }

    function makeTextSprite(text) {
      const canvas = document.createElement('canvas');
      const size = 128;
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,size,size);
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.font = 'bold 64px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, size/2, size/2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sprite = new THREE.Sprite(mat);
      const scale = 0.35; // visual size
      sprite.scale.set(scale, scale, 1);
      return sprite;
    }

    // ===================== Orientation & geolocation =====================
    function handleOrientation(e) {
      const alpha = deg2rad(e.alpha || 0); // yaw
      const beta  = deg2rad(e.beta  || 0); // pitch
      const gamma = deg2rad(e.gamma || 0); // roll

      // Convert to quaternion using YXZ convention (common for DeviceOrientation)
      const euler = new THREE.Euler();
      euler.set(beta, alpha, -gamma, 'YXZ');
      deviceQuat.setFromEuler(euler);

      // Phone "forward" is its +Y axis (top edge). Ignore roll by aligning +Y to that vector.
      const forward = new THREE.Vector3(0, 1, 0).applyQuaternion(deviceQuat).normalize();
      rollIndependentQuat.setFromUnitVectors(new THREE.Vector3(0,1,0), forward);

      realArrow.setRotationFromQuaternion(rollIndependentQuat);
    }

    function requestOrientationPermission() {
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        // iOS Safari: must be triggered by a user gesture; try immediately, else retry on menu-button tap.
        DeviceOrientationEvent.requestPermission()
          .then(state => {
            if (state === 'granted') {
              window.addEventListener('deviceorientation', handleOrientation, true);
            } else {
              infoEl.textContent = 'Motion permission denied. Tap "Set Target" and allow motion.';
              // Fallback: bind on first user gesture
              document.getElementById('menuButton').addEventListener('click', () => {
                DeviceOrientationEvent.requestPermission().then(s => {
                  if (s === 'granted') window.addEventListener('deviceorientation', handleOrientation, true);
                }).catch(()=>{});
              }, { once: true });
            }
          })
          .catch(() => {
            // If requestPermission crashes, try listening anyway (Android/other browsers)
            window.addEventListener('deviceorientation', handleOrientation, true);
          });
      } else {
        // Android / older iOS: direct listen
        window.addEventListener('deviceorientation', handleOrientation, true);
      }
    }

    function initGeolocation() {
      if (!navigator.geolocation) {
        infoEl.textContent = 'Geolocation not supported on this device/browser.';
        return;
      }
      navigator.geolocation.watchPosition(
        pos => {
          currentPos.lat  = pos.coords.latitude;
          currentPos.lon  = pos.coords.longitude;
          // If altitude is null/undefined, keep previous elev (0 default)
          if (typeof pos.coords.altitude === 'number') currentPos.elev = pos.coords.altitude;
        },
        err => {
          infoEl.textContent = 'GPS error: ' + err.message;
        },
        { enableHighAccuracy: true, maximumAge: 1500, timeout: 7000 }
      );
    }

    // ===================== Target update & alignment =====================
    function updateTargetArrow() {
      if (!target || currentPos.lat == null || currentPos.lon == null) return;

      const brg = bearingTo(currentPos.lat, currentPos.lon, target.lat, target.lon);
      const elev = elevationAngle(currentPos.lat, currentPos.lon, currentPos.elev, target.lat, target.lon, target.elev);

      const dir = dirFromBearingElevation(brg, elev);
      const qTgt = quatToPointPlusY(dir);

      targetArrow.setRotationFromQuaternion(qTgt);
      targetArrow.visible = true;

      // Compute angular difference between phone forward and target direction
      const phoneFwd = new THREE.Vector3(0,1,0).applyQuaternion(rollIndependentQuat).normalize();
      const dot = Math.min(1, Math.max(-1, phoneFwd.dot(dir)));
      const deltaDeg = rad2deg(Math.acos(dot));

      // Visual feedback
      if (deltaDeg < ALIGN_TOLERANCE_DEG) {
        targetArrow.material.color.set(0xff0000);
      } else {
        targetArrow.material.color.set(0xffffff);
      }

      infoEl.textContent =
        `Δ=${deltaDeg.toFixed(2)}° | Bearing ${brg.toFixed(1)}° | Elev ${elev.toFixed(1)}°` +
        (currentPos.elev ? ` | Alt ${currentPos.elev.toFixed(0)}m` : '');
    }

    // ===================== Render loop =====================
    function animate() {
      requestAnimationFrame(animate);
      if (target) updateTargetArrow();
      renderer.render(scene, camera);
    }

    // ===================== UI: menu & actions =====================
    const menuBtn = document.getElementById('menuButton');
    const overlay = document.getElementById('menuOverlay');
    const wpLatEl = document.getElementById('wpLat');
    const wpLngEl = document.getElementById('wpLng');
    const wpElevEl = document.getElementById('wpElev');
    const fetchElevBtn = document.getElementById('fetchElev');
    const setTargetBtn = document.getElementById('setTarget');
    const closeMenuBtn = document.getElementById('closeMenu');
    const wpListEl = document.getElementById('waypointList');

    menuBtn.onclick = () => {
      overlay.style.display = 'flex';
      // Pre-fill current cursor if empty
      if (!wpLatEl.value && currentPos.lat != null) wpLatEl.value = currentPos.lat.toFixed(6);
      if (!wpLngEl.value && currentPos.lon != null) wpLngEl.value = currentPos.lon.toFixed(6);
    };

    closeMenuBtn.onclick = () => overlay.style.display = 'none';

    fetchElevBtn.onclick = async () => {
      const lat = parseFloat(wpLatEl.value), lon = parseFloat(wpLngEl.value);
      if (Number.isNaN(lat) || Number.isNaN(lon)) {
        alert('Enter valid latitude and longitude first.');
        return;
      }
      wpElevEl.value = '…';
      const elev = await fetchElevation(lat, lon);
      if (elev !== null) wpElevEl.value = (+elev).toFixed(1);
      else {
        alert('Elevation lookup failed. Enter it manually if known.');
        wpElevEl.value = '';
      }
    };

    setTargetBtn.onclick = () => {
      const lat = parseFloat(wpLatEl.value);
      const lon = parseFloat(wpLngEl.value);
      const elev = parseFloat(wpElevEl.value);
      if ([lat,lon,elev].some(v => Number.isNaN(v))) {
        alert('Please enter numeric values for latitude, longitude, and elevation.');
        return;
      }
      target = { lat, lon, elev };
      overlay.style.display = 'none';
    };

    // ===================== Boot =====================
    initScene();
    requestOrientationPermission();
    initGeolocation();
    animate();
  </script>
</body>
</html>
