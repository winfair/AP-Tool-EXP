<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>3D Spatial Compass — Precision Alignment Tool</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:#000; color:#fff;
    height:100%; width:100%; font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
    touch-action:none; -webkit-user-select:none; user-select:none; }
  #info { position:fixed; top:10px; left:10px; right:150px; z-index:12;
    font-size:14px; line-height:1.35; opacity:0.95; text-shadow:0 0 4px #000; }
  #menuButton { position:fixed; top:10px; right:10px; z-index:12;
    padding:8px 12px; font-size:15px; background:rgba(50,50,50,0.9); color:#fff;
    border:1px solid #777; border-radius:6px; }
  #enableMotion {
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:20;
    background:#1e1e1e; color:#fff; border:1px solid #888; border-radius:10px;
    padding:14px 18px; font-size:16px; box-shadow:0 8px 30px rgba(0,0,0,0.4);
  }
  #menuOverlay { position:fixed; inset:0; display:none; z-index:15;
    background:rgba(0,0,0,0.95); color:#fff; padding:20px; box-sizing:border-box;
    display:none; flex-direction:column; align-items:center; justify-content:center; }
  #menuOverlay h2 { margin:0 0 12px; }
  #menuOverlay input {
    width:85%; padding:10px; margin:7px 0; font-size:16px; border:none; border-radius:6px;
    background:#1e1e1e; color:#fff;
  }
  #menuOverlay button {
    margin:7px 0; padding:10px 14px; font-size:16px; border:1px solid #555;
    background:#333; color:#fff; border-radius:6px;
  }
  #waypointList { width:85%; max-height:200px; overflow-y:auto; border:1px solid #333;
    padding:6px; margin-top:8px; border-radius:6px; font-size:14px; }
</style>
</head>
<body>
  <div id="info">Tap “Enable Motion & Orientation”, then allow prompts. Allow location as well.</div>
  <button id="menuButton">Set Target</button>
  <button id="enableMotion">Enable Motion & Orientation</button>

  <div id="menuOverlay">
    <h2>Target Point</h2>
    <input id="wpLat" type="number" step="any" placeholder="Latitude (e.g. 34.8234)">
    <input id="wpLng" type="number" step="any" placeholder="Longitude (e.g. -118.9453)">
    <input id="wpElev" type="number" step="any" placeholder="Elevation (m)">
    <button id="fetchElev">Fetch Elevation</button>
    <button id="setTarget">Set Target</button>
    <div id="waypointList"></div>
    <button id="closeMenu">Close</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
  // ======= Globals =======
  let scene, camera, renderer;
  let realArrow, targetArrow, azRing, pitchRing;
  let deviceQuat = new THREE.Quaternion();
  let rollIndependentQuat = new THREE.Quaternion();

  const EARTH_RADIUS = 6371000; // m
  const ALIGN_TOLERANCE_DEG = 2;
  const infoEl = document.getElementById('info');
  const enableBtn = document.getElementById('enableMotion');

  let currentPos = { lat:null, lon:null, elev:0 };
  let target = null;
  let sensorActive = false;

  // ======= Math helpers =======
  const deg2rad = d => d * Math.PI / 180;
  const rad2deg = r => r * 180 / Math.PI;

  function distanceMeters(lat1,lon1,lat2,lon2){
    const φ1=deg2rad(lat1), φ2=deg2rad(lat2);
    const Δφ=φ2-φ1, Δλ=deg2rad(lon2-lon1);
    const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
    return 2*EARTH_RADIUS*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  }
  function bearingTo(lat1,lon1,lat2,lon2){
    const φ1=deg2rad(lat1), φ2=deg2rad(lat2), Δλ=deg2rad(lon2-lon1);
    const y = Math.sin(Δλ)*Math.cos(φ2);
    const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
    return (rad2deg(Math.atan2(y,x))+360)%360;
  }
  function elevationAngle(lat1,lon1,e1,lat2,lon2,e2){
    const Δe=(e2??0)-(e1??0);
    const d=distanceMeters(lat1,lon1,lat2,lon2);
    return rad2deg(Math.atan2(Δe, d));
  }
  function dirFromBearingElevation(bearingDeg,elevDeg){
    const yaw=deg2rad(bearingDeg), pitch=deg2rad(elevDeg);
    const x=Math.sin(yaw)*Math.cos(pitch);
    const y=Math.sin(pitch);
    const z=-Math.cos(yaw)*Math.cos(pitch);
    return new THREE.Vector3(x,y,z).normalize();
  }
  function quatToPointPlusY(dir){
    return new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
  }

  // ======= Elevation lookup =======
  async function fetchElevation(lat, lon){
    try{
      const r = await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lon}`);
      const j = await r.json();
      if(j && j.results && j.results.length) return j.results[0].elevation;
    }catch(e){ console.warn('Elevation fetch error', e); }
    return null;
  }

  // ======= Scene =======
  function initScene(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0,0,5);

    renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const arrowGeom = new THREE.ConeGeometry(0.22, 1.1, 40);

    const realMat = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.85});
    realArrow = new THREE.Mesh(arrowGeom, realMat);
    realArrow.rotation.x = Math.PI/2;
    scene.add(realArrow);

    const tgtMat = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.85});
    targetArrow = new THREE.Mesh(arrowGeom, tgtMat);
    targetArrow.rotation.x = Math.PI/2;
    targetArrow.visible = false;
    scene.add(targetArrow);

    azRing = makeRingWithTicks(1.85, 120, 0x00ffff, 0.28, false);
    scene.add(azRing.group);
    addCardinalLabels(azRing.radius);

    pitchRing = makeRingWithTicks(1.25, 80, 0xff00ff, 0.28, true);
    scene.add(pitchRing.group);

    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  }

  function makeRingWithTicks(radius, segs, color, opacity, vertical=false){
    const group = new THREE.Group();
    const curve = new THREE.EllipseCurve(0,0,radius,radius,0,Math.PI*2,false,0);
    const pts = curve.getPoints(segs).map(p=>new THREE.Vector3(p.x,p.y,0));
    const geom = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({color, transparent:true, opacity});
    const ring = new THREE.LineLoop(geom, mat);
    group.add(ring);

    for(let d=0; d<360; d+=10){
      const a=deg2rad(d), rOut=radius, rIn=radius-(d%90===0?0.12:0.07);
      const x1=Math.cos(a)*rOut, y1=Math.sin(a)*rOut;
      const x2=Math.cos(a)*rIn,  y2=Math.sin(a)*rIn;
      const tg = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x1,y1,0), new THREE.Vector3(x2,y2,0)]);
      const tl = new THREE.Line(tg, new THREE.LineBasicMaterial({color, transparent:true, opacity:0.45}));
      group.add(tl);
    }
    if(vertical) group.rotation.x = Math.PI/2;
    return {group, radius};
  }

  function addCardinalLabels(radius){
    const labels = [
      {t:'N', p:new THREE.Vector3(0,  radius+0.12, 0)},
      {t:'E', p:new THREE.Vector3( radius+0.12, 0, 0)},
      {t:'S', p:new THREE.Vector3(0, -radius-0.12, 0)},
      {t:'W', p:new THREE.Vector3(-radius-0.12, 0, 0)},
    ];
    for(const {t,p} of labels){
      const s = makeTextSprite(t); s.position.copy(p); scene.add(s);
    }
  }
  function makeTextSprite(text){
    const c=document.createElement('canvas'), size=128; c.width=c.height=size;
    const ctx=c.getContext('2d'); ctx.clearRect(0,0,size,size);
    ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.font='bold 64px Arial';
    ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(text,size/2,size/2);
    const tex=new THREE.CanvasTexture(c); const mat=new THREE.SpriteMaterial({map:tex, transparent:true});
    const spr=new THREE.Sprite(mat); spr.scale.set(0.35,0.35,1); return spr;
  }

  // ======= Screen orientation correction (fixes yaw when phone is flat) =======
  let screenOrientRad = 0;
  function readScreenOrientation(){
    if (screen.orientation && typeof screen.orientation.angle === 'number') return screen.orientation.angle;
    if (typeof window.orientation === 'number') return window.orientation;
    return 0;
  }
  function updateScreenOrientRad(){
    screenOrientRad = (readScreenOrientation() || 0) * Math.PI/180;
  }
  addEventListener('orientationchange', updateScreenOrientRad);
  updateScreenOrientRad();

  // ======= Orientation handler (DeviceOrientationControls math) =======
  const _zee = new THREE.Vector3(0,0,1);
  const _euler = new THREE.Euler();
  const _q0 = new THREE.Quaternion();
  const _q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // -PI/2 about X

  function onOrientation(evt){
    // Prefer iOS absolute compass if present
    let alphaDeg = (typeof evt.alpha === 'number') ? evt.alpha : 0;
    if (typeof evt.webkitCompassHeading === 'number') {
      // webkitCompassHeading: 0 at magnetic North, increasing CW
      alphaDeg = 360 - evt.webkitCompassHeading; // convert to CCW
    }

    const alpha = deg2rad(alphaDeg || 0); // yaw
    const beta  = deg2rad(evt.beta  || 0); // pitch
    const gamma = deg2rad(evt.gamma || 0); // roll

    // Build device quaternion in world frame: YXZ + fix to world + screen orientation
    _euler.set(beta, alpha, -gamma, 'YXZ');
    deviceQuat.setFromEuler(_euler);
    deviceQuat.multiply(_q1); // device -> world
    deviceQuat.multiply(_q0.setFromAxisAngle(_zee, -screenOrientRad)); // remove screen rotation

    // Forward is phone's +Y (top edge). Ignore roll: align +Y to that vector.
    const forward = new THREE.Vector3(0,1,0).applyQuaternion(deviceQuat).normalize();
    rollIndependentQuat.setFromUnitVectors(new THREE.Vector3(0,1,0), forward);

    realArrow.setRotationFromQuaternion(rollIndependentQuat);

    if(!sensorActive){ sensorActive = true; enableBtn.style.display='none'; }
  }

  // ======= Permissions & listeners =======
  async function requestMotionPermissions(){
    try{
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(_){}
      }
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        await DeviceOrientationEvent.requestPermission();
      }
    }catch(_){}
    addEventListener('deviceorientation', onOrientation, true);
    addEventListener('deviceorientationabsolute', onOrientation, true);

    setTimeout(() => {
      if (!sensorActive) {
        infoEl.textContent =
          'No motion data. On iOS: Settings → Safari → Motion & Orientation Access = ON, then reload and tap the button. Site must be HTTPS.';
      }
    }, 2000);
  }

  // ======= Geolocation =======
  function initGeolocation(){
    if(!navigator.geolocation){ infoEl.textContent='Geolocation not supported.'; return; }
    navigator.geolocation.watchPosition(pos=>{
      currentPos.lat = pos.coords.latitude;
      currentPos.lon = pos.coords.longitude;
      if (typeof pos.coords.altitude === 'number') currentPos.elev = pos.coords.altitude;
    }, err=>{
      infoEl.textContent = 'GPS error: ' + err.message;
    }, {enableHighAccuracy:true, maximumAge:1500, timeout:7000});
  }

  // ======= Target update & alignment =======
  function updateTarget(){
    if(!target || currentPos.lat==null || currentPos.lon==null) return;

    const brg = bearingTo(currentPos.lat,currentPos.lon,target.lat,target.lon);
    const elev = elevationAngle(currentPos.lat,currentPos.lon,currentPos.elev,target.lat,target.lon,target.elev);

    const dir  = dirFromBearingElevation(brg, elev);
    const qTgt = quatToPointPlusY(dir);

    targetArrow.setRotationFromQuaternion(qTgt);
    targetArrow.visible = true;

    const phoneFwd = new THREE.Vector3(0,1,0).applyQuaternion(rollIndependentQuat).normalize();
    const dot = Math.min(1, Math.max(-1, phoneFwd.dot(dir)));
    const dDeg = rad2deg(Math.acos(dot));

    targetArrow.material.color.set(dDeg < ALIGN_TOLERANCE_DEG ? 0xff0000 : 0xffffff);

    infoEl.textContent =
      `Δ=${dDeg.toFixed(2)}° | Bearing ${brg.toFixed(1)}° | Elev ${elev.toFixed(1)}°` +
      (currentPos.elev ? ` | Alt ${currentPos.elev.toFixed(0)}m` : '');
  }

  // ======= Render loop =======
  function animate(){
    requestAnimationFrame(animate);
    if (target) updateTarget();
    renderer.render(scene,camera);
  }

  // ======= UI =======
  const menuBtn = document.getElementById('menuButton');
  const overlay = document.getElementById('menuOverlay');
  const wpLatEl = document.getElementById('wpLat');
  const wpLngEl = document.getElementById('wpLng');
  const wpElevEl = document.getElementById('wpElev');
  const fetchElevBtn = document.getElementById('fetchElev');
  const setTargetBtn = document.getElementById('setTarget');
  const closeMenuBtn = document.getElementById('closeMenu');

  menuBtn.onclick = () => {
    overlay.style.display='flex';
    if(!wpLatEl.value && currentPos.lat!=null) wpLatEl.value = currentPos.lat.toFixed(6);
    if(!wpLngEl.value && currentPos.lon!=null) wpLngEl.value = currentPos.lon.toFixed(6);
  };
  closeMenuBtn.onclick = () => overlay.style.display='none';
  fetchElevBtn.onclick = async () => {
    const lat=parseFloat(wpLatEl.value), lon=parseFloat(wpLngEl.value);
    if (Number.isNaN(lat)||Number.isNaN(lon)) { alert('Enter valid latitude/longitude'); return; }
    wpElevEl.value='…';
    const elev = await fetchElevation(lat, lon);
    if (elev!==null) wpElevEl.value=(+elev).toFixed(1); else { alert('Elevation lookup failed'); wpElevEl.value=''; }
  };
  setTargetBtn.onclick = () => {
    const lat=parseFloat(wpLatEl.value), lon=parseFloat(wpLngEl.value), elev=parseFloat(wpElevEl.value);
    if([lat,lon,elev].some(v=>Number.isNaN(v))){ alert('Please enter numeric lat/lon/elev'); return; }
    target = {lat, lon, elev};
    overlay.style.display='none';
  };

  // ======= Boot =======
  initScene();
  initGeolocation();
  animate();

  enableBtn.addEventListener('click', requestMotionPermissions);
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && !sensorActive) {
      enableBtn.style.display = 'block';
      infoEl.textContent = 'Tap “Enable Motion & Orientation”, then allow prompts.';
    }
  });
  </script>
</body>
</html>
