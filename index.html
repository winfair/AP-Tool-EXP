<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Geo Arrow — Real‑Direction Pointer</title>
  <style>
    :root {
      --bg: #0b0f12;
      --ink: #e8f1f0;
      --line: rgba(255,255,255,.16);
      --muted: #9fc0b8;
      --brand: #22d7b7;
      --accent: #ff4d4d;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(120% 140% at 50% 20%, #131a20 0%, #0b0f12 60%, #06080a 100%);
      color: var(--ink);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial, sans-serif;
    }
    #canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
    .panel {
      position: fixed;
      left: 12px;
      top: 12px;
      z-index: 10;
      background: rgba(10,14,18,.76);
      border:1px solid var(--line);
      backdrop-filter: blur(6px);
      padding:.8rem;
      border-radius:14px;
      display:flex;
      flex-direction:column;
      gap:.55rem;
      max-width:min(92vw,520px);
    }
    .row {
      display:flex; gap:.5rem; flex-wrap:wrap;
    }
    .row>label {
      display:flex; flex:1 1 42%; align-items:center;
      gap:.35rem;
      background:rgba(255,255,255,.05);
      border:1px solid var(--line);
      padding:.35rem .5rem;
      border-radius:10px;
    }
    input[type=number], input[type=text] {
      width:100%; background:transparent; border:none; outline:none;
      color: var(--ink); font‑variant‑numeric: tabular‑nums;
    }
    input[type=range] { width: 100%; }
    .btn {
      appearance:none; border:1px solid var(--line);
      background: rgba(255,255,255,.06); color: var(--ink);
      padding:.52rem .8rem; border-radius:12px; font-weight:600;
      cursor:pointer;
    }
    .btn:active { transform: translateY(1px); }
    .tiny { font-size:.85rem; color: var(--muted); }
    #readout {
      position: fixed; left:12px; bottom:12px; opacity:.95;
      font‑variant‑numeric: tabular‑nums;
      background: rgba(0,0,0,.32); padding:.42rem .65rem;
      border-radius:10px; border:1px solid var(--line);
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="panel">
  <div class="tiny">
    Arrow points to target in **real‑world direction**. Move i.e. rotate your device and the arrow will stay aligned.
  </div>
  <div class="row">
    <label>Lat° <input id="tLat" type="number" step="0.000001" placeholder="e.g. 48.137" /></label>
    <label>Lon° <input id="tLon" type="number" step="0.000001" placeholder="e.g. 11.575" /></label>
  </div>
  <div class="row">
    <label>Alt (m) <input id="tAlt" type="number" step="0.1" placeholder="0" /></label>
    <button id="setTarget" class="btn">Set Target</button>
  </div>
  <div class="row">
    <button id="useGps" class="btn">Use My Location</button>
    <button id="calYaw" class="btn">Calibrate</button>
    <button id="perm" class="btn">Enable Sensors</button>
  </div>
  <div class="row">
    <label>Stability <input id="stab" type="range" min="0" max="0.9" step="0.01" value="0.18"/></label>
    <label>Deadband° <input id="dead" type="number" step="0.1" value="0.5"/></label>
  </div>
  <div class="tiny" id="status">Status: awaiting target & location…</div>
</div>

<div id="readout">az: —° el: —° | me: —, —, —m</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js" crossorigin="anonymous"></script>
<script>
(() => {
  const canvas = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 1000);
  camera.position.set(0,0,0);  // camera is at origin (device position)
  const rig = new THREE.Group();
  rig.add(camera);
  scene.add(rig);

  // Arrow at some distance forward in scene
  const arrow = new THREE.ArrowHelper(
    new THREE.Vector3(0,0,1),  // initial direction forward (we’ll update)
    new THREE.Vector3(0,0,0),
    10,  // length
    0xff4d4d
  );
  scene.add(arrow);

  // Light so arrow is visible
  const light = new THREE.DirectionalLight(0xffffff,0.6);
  light.position.set(1,2,3);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0xffffff,0.8));

  // UI References
  const tLat   = document.getElementById('tLat');
  const tLon   = document.getElementById('tLon');
  const tAlt   = document.getElementById('tAlt');
  const btnSet = document.getElementById('setTarget');
  const btnGPS = document.getElementById('useGps');
  const btnCal = document.getElementById('calYaw');
  const btnPerm= document.getElementById('perm');
  const stab   = document.getElementById('stab');
  const dead   = document.getElementById('dead');
  const statusEl = document.getElementById('status');
  const readout = document.getElementById('readout');

  // State
  let obs = {lat:0, lon:0, alt:0, valid:false};
  let tgt = {lat:0, lon:0, alt:0, valid:false};
  let yaw=0, pitch=0, roll=0;
  let yawCal=0, yawSm=0, pitchSm=0, rollSm=0;

  // WGS‑84
  const a = 6378137;
  const f = 1/298.257223563;
  const e2 = f*(2 - f);
  const d2r = d => d * Math.PI/180;
  const r2d = r => r * 180/Math.PI;

  function geodeticToECEF(lat, lon, h) {
    const φ = d2r(lat), λ = d2r(lon);
    const s = Math.sin(φ), c = Math.cos(φ);
    const N = a / Math.sqrt(1 - e2*s*s);
    const x = (N + h)*c*Math.cos(λ);
    const y = (N + h)*c*Math.sin(λ);
    const z = (N*(1 - e2) + h)*s;
    return {x,y,z};
  }

  function ecefToENU(dx, dy, dz, lat0, lon0) {
    const φ = d2r(lat0), λ = d2r(lon0);
    const sφ = Math.sin(φ), cφ = Math.cos(φ);
    const sλ = Math.sin(λ), cλ = Math.cos(λ);
    const e = -sλ*dx + cλ*dy;
    const n = -sφ*cλ*dx - sφ*sλ*dy + cφ*dz;
    const u =  cφ*cλ*dx + cφ*sλ*dy + sφ*dz;
    return {e,n,u};
  }

  function computeDirectionVector() {
    if (!obs.valid || !tgt.valid) return null;
    const A = geodeticToECEF(obs.lat, obs.lon, obs.alt);
    const B = geodeticToECEF(tgt.lat, tgt.lon, tgt.alt);
    const dx = B.x - A.x, dy = B.y - A.y, dz = B.z - A.z;
    const enu = ecefToENU(dx, dy, dz, obs.lat, obs.lon);
    // east = +X, north = +Z, up = +Y
    const dir = new THREE.Vector3(enu.e, enu.u, enu.n).normalize();
    return {direction: dir, az: Math.atan2(enu.e, enu.n), el: Math.atan2(enu.u, Math.hypot(enu.e, enu.n))};
  }

  function updateArrowDirection() {
    const res = computeDirectionVector();
    if (!res) {
      readout.textContent = `az: —° el: —° | me: ${obs.lat.toFixed(6)}, ${obs.lon.toFixed(6)}, ${(obs.alt||0).toFixed(1)}m`;
      return;
    }
    const k = parseFloat(stab.value) || 0.18;
    yawSm   = yawSm   + wrapRad(yaw - yawSm)*k;
    pitchSm = pitchSm + (pitch - pitchSm)*k;
    rollSm  = rollSm  + (roll  - rollSm )*k;

    // Set camera rig orientation from device orientation
    rig.rotation.set(
      THREE.MathUtils.degToRad(pitchSm),
      THREE.MathUtils.degToRad(yawSm + yawCal),
      THREE.MathUtils.degToRad(rollSm)
    );

    // Now arrow direction in world space — set its direction
    arrow.setDirection(res.direction);

    readout.textContent = `az: ${r2d(res.az).toFixed(1)}° el: ${r2d(res.el).toFixed(1)}° | me: ${obs.lat.toFixed(6)}, ${obs.lon.toFixed(6)}, ${(obs.alt||0).toFixed(1)}m`;
  }

  function wrapRad(a) {
    a %= (2*Math.PI);
    if (a < -Math.PI) a += 2*Math.PI;
    if (a >  Math.PI) a -= 2*Math.PI;
    return a;
  }

  // UI Handlers
  btnSet.addEventListener('click', () => {
    const lat = parseFloat(tLat.value);
    const lon = parseFloat(tLon.value);
    const alt = parseFloat(tAlt.value)||0;
    if (Number.isFinite(lat) && Number.isFinite(lon)) {
      tgt = {lat, lon, alt, valid:true};
      statusEl.textContent = "Status: target set.";
      updateArrowDirection();
    } else {
      statusEl.textContent = "Status: enter valid target lat/lon.";
    }
  });

  btnGPS.addEventListener('click', () => {
    if (!('geolocation' in navigator)) {
      statusEl.textContent = "Status: Geolocation not available.";
      return;
    }
    navigator.geolocation.watchPosition(pos => {
      const c = pos.coords;
      const kLoc = 0.25;
      if (!obs.valid) {
        obs = { lat:c.latitude, lon:c.longitude, alt:c.altitude||0, valid:true };
      } else {
        obs.lat = obs.lat*(1-kLoc) + c.latitude*kLoc;
        obs.lon = obs.lon*(1-kLoc) + c.longitude*kLoc;
        obs.alt = obs.alt*(1-kLoc) + (c.altitude||0)*kLoc;
      }
      statusEl.textContent = "Status: tracking your location…";
      updateArrowDirection();
    }, err => {
      statusEl.textContent = `Status: GPS error — ${err.message}`;
    }, {enableHighAccuracy:true, maximumAge:3000, timeout:15000});
  });

  btnCal.addEventListener('click', () => {
    yawCal = - yaw; 
    statusEl.textContent = "Status: yaw calibrated.";
  });

  btnPerm.addEventListener('click', async () => {
    try {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission==='function') {
        await DeviceOrientationEvent.requestPermission();
      }
    } catch(e) {}

    const onDO = (e) => {
      if (typeof e.webkitCompassHeading === 'number') {
        yaw   = e.webkitCompassHeading;
      } else if (typeof e.alpha === 'number') {
        yaw   = (360 - e.alpha)%360;
      }
      pitch = (typeof e.beta === 'number' ? e.beta - 90 : 0);
      roll  = (typeof e.gamma === 'number' ? e.gamma : 0);
      updateArrowDirection();
    };

    window.addEventListener('deviceorientationabsolute' in window ? 'deviceorientationabsolute':'deviceorientation', onDO, true);

    statusEl.textContent = "Status: sensors enabled.";
  });

  // Resize + animate
  function resize() {
    const w = canvas.clientWidth || window.innerWidth;
    const h = canvas.clientHeight || window.innerHeight;
    renderer.setSize(w,h,false);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();

})();
</script>
</body>
</html>
